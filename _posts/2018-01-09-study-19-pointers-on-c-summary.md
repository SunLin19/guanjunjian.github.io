---
layout:     post
title:      "study19.《C和指针》知识点总结"
date:       2018-01-09 10:00:00
author:     "guanjunjian"
categories: 读书
tags:
    - study
    - summary
---

* content
{:toc}

>
> 《C和指针》 知识要点总结，持续更新
>




# 第3章 数据

-   作用域、链接属性 ---> 可视性（可以在什么地方使用）
-   存储类型 ---> 生命期（值将保持多久）

## 3.1 基本数据类型

-   4种基本数据类型：整型、浮点型、指针和聚合类型（数组、结构）

### 3.1.1 整型家族

-   1.整型家族包括字符、短整型、整型和长整型，又分为有符号和无符号
    -   a.字符：char、signed char、unsigned char（char和unsigend char长度不一样的）
    -   b.短整型：short int（至少16位）、unsigned short int
    -   c.整型：int、unsigned int
    -   d.长整型：long int（至少32位）、unsigend long int
-   2.长度比较：`长整型 >= 整型 >= 短整型`
-   3.头文件limits.h说明了各种不同的整型类型的特点：变量范围的限制
-   4.char类型变量在本质上是小整型值
-   5.缺省的char要么是sigend char，要么是unsigend char，这取决于编译器
-   6.char变量的值位于sigend char和unsigend char的交集中，这个程序才是可移植的
-   7.移植问题：最佳方案是将char限制在sigend char和unsigend char交集内，并且只有char显示声明为sigend或unsigend时才对它执行算术运算

---

# 第5章 操作符和表达式

## 5.1 操作符

### 5.1.1 算数操作符

-   1.`+ - * / %`
-   2.`%`只能用于整数类型

### 5.1.2 位移操作符


-   1.`<<`左移操作，移出界的丢弃
-   2.`>>`右移，左边移入新位时有两种方案
    -   a. 逻辑移位：左边移入的用0填充
    -   b. 算数移位：左边移入的由原先的符号位决定
-   3.位移操作符的两个操作数都必须是整形类型
-   4.无符号值都是逻辑位移，有符号值由编译器决定
-   5.`a << -5`这个位移的值是不可预测的

### 5.1.3 位操作符

-   1.AND、OR、XOR; `&、|、^`

### 5.1.4 赋值

-   1.赋值是表达式的一种，而不是某种类型的语句（没有赋值语句）
-   2.赋值是表达式，所以它就具有一个值，赋值表达式的值就是左操作数的新值，可以作为其他赋值操作符的右操作数，如`a = x = y + 3`,即`a = ( x = y + 3 )`
-   3.`a = x = y + 3`认为a和x被赋予相同的值的说法是错误的，因为可能变量类型不同，比如x是字符型变量，那么y+3的值就会被截去一段，所以以下代码是错误的（具体参照P70）
    - a.   
        ```
        char ch;
        ...
        while( ( ch = getchar() ) != EOF )...
        ```
-   4.复合赋值符：`+=、<<=、&=`等等，`a += expression`等于`a += a + ( expression )`

### 5.1.5 单目操作符

`!、++、-、&、sizeof、~、--、+、*、(类型)`

-   1.`~`:按位取反
-   2.`-`：负值
-   3.`+`:正值，与`-`相对
-   4.`&`:取地址
-   5.`*`:间接访问操作符，与指针一起用
-   6.`sizeof`:操作数的类型长度，字节为单位;`sizeof (int)`、`sizeof x`;当操作数为数组名时，返回数组的长度，以字节为单位;判断表达式的长度不需要对表达式求值，所以`sizeof( a = b + 1 )`并没有向a赋值
-   7.`(类型)`：强制类型转换
-   8.`++和--`:操作数必须是个“左值”；前缀形式：操作数的值被增加，表达式是操作数增加后的值；后缀形式：操作数的值被增加，表达式是增加前的值；增值操作符都是复制一份变量值的拷贝，用于表达式的值正式这份拷贝，前缀后缀只是复制的时间不一样，因此`++a = 10`是错误的，因为不能向一个拷贝值进行赋值（P73）

### 5.1.6 关系操作符

`>   >=   <   <=   !=   ==`

-   这些操作符产生的结果都是整型值1或0，不是布尔值

### 5.1.7 逻辑操作符

`&&   ||`

-   短路求值

### 5.1.8 条件操作符

`expression1 ? expression2 : expression3`

### 5.1.9 逗号操作符

`,`

-   逗号操作符将多个表达式分隔开来，这些表达式自左向右逐个进行求值
-   `if( b + 1, c / 2, d > 0)`这里看的是`d > 0`

### 5.1.10 下标引用、函数调用和结构函数

-   C的下标值总是从0开始，并且不会对下标值进行有效性验证
-   除了优先级不同外，下标引用操作和间接访问表达式是等价的
    -   `array[ 下标 ]`和`*( array + ( 下标 ) )`
-   `.`和`->`操作符用于访问一个结构的成员，当你拥有一个指向结构体的指针而不是结构体本身时，使用`->`访问它的成员

---

## 5.2 布尔值

-   C不具备显示的布尔类型，使用整数代替
-   零是假，任何非零值为真
-   注意这类写法，flag为1以外的其他非零值，这个if语句也是不执行的：
    - a.
    ```
    #define FALSE 0
    #define TRUE 1
    if( flag == TRUE)
    ```
---

## 5.3 左值和右值

-   左值就是那些能够出现在复制符号左边的东西，右值同理
-   “表达式不能作为左值”这句话是错的：`a[ b + 10 ] = 0`中的左值就是表达式，这些操作符包括间接访问操作符和下标引用

---

## 5.4 表达式求值

### 5.4.1 隐式类型转换

-   整型升级：字符型加法运算时，会提升为普通整型

### 5.4.2 算术转换

-   寻常算术转化（P80）

### 5.4.3 操作符的属性

-   复杂表达式的求值顺序3个决定因素：操作符的优先顺序、操作符的结合性（`L-R`、`R-L`）、操作符是否控制执行的顺序（`&&`、`||`）
-   操作符优先级表 p81

### 5.4.4 优先级和求值的顺序

-   `c + --c`根据编译器的不同会产生不同的结果

---

## 5.5 总结

-   `&&`、`||`和`?:`对求值过程施加控制
-   逗号操作符，整个表达式的值是最右那个子表达式的值
-   各个不同类型之间的值不能直接进行运算，除非其中一个的操作数转换为另一个操作数的类型（寻常算术转换）
-   表达式的结果如果依赖于求值的顺序，那么它在本质上就是不可移植的，应该避免使用（P86）
-   不要混用整型和布尔型值

---

# 第6章 指针

## 6.1 内存和地址

-   字节：8个位
-   字：许多机器以字为单位存储整数，每个字一般由2个或4个字节组成
-   尽管一个字包含了4个字节，它仍然有一个地址，或是最左边那个字节或是最右边那个字节
-   边界对齐
-   内存中的每个位置都由一个独一无二的地址标识；内存中的每个位置都包含一个值

---

## 6.2 值和类型

-   不能简单地通过检查一个值的位来判断它的类型，为了判断值的类型，必须观察程序中这个值的使用方式

---

## 6.3 指针变量的内容

-   一个变量的值就是分配给这个变量的内存位置所存储的数值，要区分与指针的内容

---

## 6.4 间接访问操作符

-   通过一个指针访问它所指向的地址的过程称为间接访问或解引指针，使用`*`

---

## 6.5 未初始化和非法的指针

    ```
    int *a;
    ...
    *a =12;
    ```
    
-   是错误的，因为没有对a进行初始化

---

## 6.6 NULL指针

-   要使一个指针变为NULL，你可以给它赋一个零值
-   为了测试一个指针变量是否为NULL，你可以将它与零值进行比较
-   对一个NULL指针进行解引用操作是非法的

---

## 6.7 指针、间接访问和左值

-   间接访问操作符所需要的操作数是一个右值，但这个操作符所产生的结果是个左值

---

## 6.8 指针、间接访问和变量

-   `*&a = 25`和`a = 25`从结果上来说是一样的

##  6.9 指针常量

-   `*100 = 25`是非法的
-   `*(int *)100 = 25`是合法的
-   指针常量通常用来根据已经设备的设备地址来访问设备

---

## 6.10 指针的指针

-   声明：`int **c`
-   声明为register的指针变量，不可以再使用&取址（P99）

---

## 6.11 指针表达式

-   cp作为字符指针，`++cp`是不能成为左值的，这个运行结果的返回值是原cp指向地址的下1个地址
-   cp作为字符指针，`cp--`是不能成为左值的，这个运行结果的返回值是原cp指向的地址
-   对于`*++cp`、`*cp++`、`++*cp`参考P103
-   由于后缀`++`的优先级高于`*`,所以`*cp++`分为三步：
    -   1. ++操作产生cp的一份拷贝
    -   2. 然后++操作符增加cp的值
    -   3. 最后，在cp的拷贝上执行间接访问操作
-   `++*++cp`、`++*cp++`参考P104

---

## 6.12 实例

---

## 6.13 指针运算

-   指针加上一个整数的结果是另一个指针，如果p是个指向float的指针，那么p+1就指向下一个float

### 6.13.1 算术运算

-   C的指针算术运算只限于两种形式：1.`指针 +/- 整数`；2.`指针 - 指针`
-   `指针 +/- 整数`
    -   标准定义这种形式只能用于指向数组中某个元素的指针
    -   这类表达式的结果类型也是指针
-   `指针 - 指针`
    -   只有当两个指针都指向同一个数组中的元素时，才允许一个指针减去另一个指针
    -   结果类型是ptrdiff_t，一种有符号整数类型
    -   减法运算的值时两个指针在内存中的距离，以数组元素的长度为单位，不是以字节为单位
    -   ptrdiff_t = 实际内存差 / 数组类型长度
    -   存在`p1 - p2 = 负数`的情况，只要两个指针都指向同一个数组的元素

### 6.13.2 关系运算

-   `<      <=      >       >=`
-   前提是指向同一个数组中的元素
-   比较表达式将告诉你哪个指针指向数组中更前或更后的元素

---

## 6.14 总结

-   无法通过值的位模式来判断它的类型，类型是通过值的使用方式隐形确定的
-   声明一个指针变量并不会自动分配任何内存，在指针执行间接访问前，指针必须进行初始化，或使它指向现有的内存，或给它分配动态内存
-   NULL指针执行间接访问操作的后果因编译器而异，常见后果为：返回内存位置零的值或终止程序
-   指针常量：通过把整型值强行转换为指针类型来创建它
-   指针加法运算，如果指针指向数组最后一个元素后面的那个内存位置仍是合法的
-   

---

## 6.15 警告

-   错误地对一个未初始化的指针变量进行解引用
-   错误地对一个NULL指针进行解引用
-   向函数错误地传递NULL指针
-   未检测到指针表达式的错误，从而导致不可预料的结果
-   对一个指针进行减法运算，使它非法地指向了数组第1个元素的前面的内存位置
---

# 第7章 函数

## 7.1 函数定义

-   函数的定义就是函数体的实现
-   函数声明出现在函数被调用的地方，函数声明向编译器提供函数的相关信息，用于确保函数被正确地调用
-   存根(stub)：应该就是一个空函数。编写这类存根，或者说为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性，以便于你编译和测试程序的其他部分
    ```
    function_name()
    {
    }
    ```
-   过程类型的函数：没有返回值
-   真函数：从表达式内部调用的，必须返回一个值，用于表达式的求值

---

## 7.2 函数声明

### 7.2.1 原型

-   第2种向编译器提供函数信息的方法是使用函数原型（第1种应该是函数定义）
-   使用原型最方便的方法是把原型置于一个单独的文件，使用`#include`指令包含该文件
-   `int func( int i );`中`;`区分了函数原型和函数定义的起始部分
-   原型中的参数名字并不是必需的
-   函数原型具有文件作用域，所以原型的一份拷贝可以作用于整个源文件
-   函数原型必须与函数定义匹配
-   `int *func()`不能表示一个没有参数的函数的原型，因为旧式风格的有参函数是可以这样声明的，一个没有参数的函数原型应该写成`int *func(void)`

### 7.2.2 函数的缺省认定

-   当程序调用一个无法见到原型的函数时，编译器认为该函数返回一个整型值
-   所有的函数都应该具有原型，尤其是那些返回值不是整型的函数
-   如果编译器认定函数返回一个整型值，它将产生整型数指令操作这个值（如果返回的不是整型值，那将会出错，例子参考P121）

---

## 7.3 函数的参数

-   1.所有参数均以“传值调用”方式进行传递，这意味着函数将获得参数值的一份拷贝
-   2.数组并不会得到一份拷贝，而是得到数组首地址的一份拷贝，这个行为被称为“传值调用”，因为数组名的值实际上是一个指针，传递给函数的就是这个指针的一份拷贝
-   3.记住两个规则：
    -   a.传递给函数的标量参数是传值调用的
    -   b.传递给函数的数组参数在行为上就像它们是通过传址调用的那样
-   4.在函数参数声明中，声明数组参数时不指定它的长度是合法的，因为函数并不为数组元素分配内存

---

## 7.4 ADT和黑盒

-   C可以用于设计和实现抽象数据类型（ADT，abstract data type），也被称为黑盒设计
-   抽象数据类型的基本想法：模块具有功能说明和接口说明
-   限制对模块的访问是通过`static`关键字的合理使用实现的，它可以限制那些并非接口的函数和数据的访问

---

## 7.5 递归

-   C通过运行时堆栈支持递归函数的实现，递归函数就是直接或间接调用自身的函数。

### 7.5.1 追踪递归函数

-   追踪一个递归函数执行过程的关键是理解函数中所声明的变量是如何存储的，因此可以通过画堆栈图来理解（参考P128的例子）

### 7.5.2 递归与迭代

-   1.递归函数调用将涉及一些运行时开销
    -   a.参数必须压到堆栈中
    -   b.为局部变量分配内存空间
    -   c.寄存器的值必须保存
-   2.因此递归函数的开销是十分大的
-   3.尾部递归：当一个函数在递归调用返回之后不再执行任何任务，这样的递归函数叫尾部递归
-   4.尾部递归可以很方便地转换成一个简单循环，完成相同任务，但开销更小
-   5.迭代实现往往比递归实现效率更高，但代码可读性稍差
-   6.如果一个问题相当复杂，难以用迭代形式实现时，此时递归实现的简便性可以补偿它所带来的运行时开销

---

## 7.6 可变参数列表

-   1.宏是由预处理器实现的
-   2.可变参数列表是通过宏来实现的，这些宏定义于stdarg.h头文件，它是标准库的一部分
-   3.分别有一个类型`va_list`和三个宏`va_start`、`va_arg`和`va_end`
-   4.参数列表中的省略号提示此处可能传递数量和类型未确定的参数，编写函数原型时，也要使用同样的记法
-   5.可变参数必须从头到尾按顺序逐个访问，半途终止是可以的，但不能一开始就访问参数列表中的中间的参数
-   6.由于可变参数部分没有原型，可变参数传递给函数的值都将执行缺省参数类型的提升（//TODO 不明白什么意思）
-   7.这些宏存在两个基本限制，是由“一个值的类型无法简单地通过检查它的位模式来判断”导致的
    -   a.这些宏无法判断实际存在的参数的数量
    -   b.这些宏无法判断每个参数的类型
-   8.要回答`7.`中的两个问题，就必须使用命名参数
        

```c
#include <stdarg.h>

float
average ( int n_values, ...)
{
    //用于访问参数列表的未确定部分
    va_list var_agr;
    int count;
    float sum = 0;
    
    //使用va_start来初始化，第1个参数是va_list变量的名字，第2个参数是省略号前最后一个有名字的参数，初始化过程把var_arg变量指向可变参数部分的第1个参数
    va_start( var_agr, n_values );
    
    for( count =0; count < n_values; count +=1 ){
        //访问参数，第1个变量va_list变量，第2个变量，参数列表中下一个参数的类型。va_arg返回这个参数的值，并使var_arg指向下一个可变参数
        sum += va_arg( var_arg, int );
    }
    //访问完毕最后一个可变参数之后，需要调用va_end
    va_end( var_arg );
    
    return sum / n_values;
}
```

---

## 7.7 总结

-   1.参数列表有两种可以接受的形式：K&R C风格和新风格
-   2.函数声明也有两种可以接受的形式：
    -   a.K&C C每个没有参数列表，只声明了返回值的类型
    -   b.新风格又称为函数原型，包含了参数列表的声明
-   3.对于那些没有原型的函数，传递给函数的实参将进行缺省参数提升
    -   a.char和short转换为int
    -   b.float转换为double