---
layout:     post
title:      "study19.《C和指针》知识点总结"
date:       2018-01-09 10:00:00
author:     "guanjunjian"
categories: 读书
tags:
    - study
    - summary
---

* content
{:toc}

>
> 《C和指针》 知识要点总结，持续更新
>




# 第3章 数据

-   作用域、链接属性 ---> 可视性（可以在什么地方使用）
-   存储类型 ---> 生命期（值将保持多久）

## 3.1 基本数据类型

-   4种基本数据类型：整型、浮点型、指针和聚合类型（数组、结构）

### 3.1.1 整型家族

-   1.整型家族包括字符、短整型、整型和长整型，又分为有符号和无符号
    -   a.字符：char、signed char、unsigned char（char和unsigend char长度不一样的）
    -   b.短整型：short int（至少16位）、unsigned short int
    -   c.整型：int、unsigned int
    -   d.长整型：long int（至少32位）、unsigend long int
-   2.长度比较：`长整型 >= 整型 >= 短整型`
-   3.头文件limits.h说明了各种不同的整型类型的特点：变量范围的限制
-   4.char类型变量在本质上是小整型值
-   5.缺省的char要么是sigend char，要么是unsigend char，这取决于编译器
-   6.char变量的值位于sigend char和unsigend char的交集中，这个程序才是可移植的
-   7.移植问题：最佳方案是将char限制在sigend char和unsigend char交集内，并且只有char显示声明为sigend或unsigend时才对它执行算术运算

#### 一、整型字面值

-   字面值是字面值常量的缩写，区分与常量
-   整型字面值属于哪种类型，取决于字面值是如何书写的，可以通过添加一个后缀来改变缺省的规则
-   在整数字面值后面添加L或l使这个整数解释为long整型值；U或u解释为unsigned整型值；可两个一起用

</br>

-   十进制整型字面值可能是`int、long或unsigend long`，缺省是它最短类型但能完整容纳这个值
-   八进制和十六进制整型字面值可能是`int、unsigend int、long或unsigend long`，，缺省是它最短类型但能完整容纳这个值
-   字符常量的类型总是`int`，不能添加unsigned或long后缀
    -   字符常量就是用一个单引号包围起来的单个字符（或字符转义序列或三个字母）例子在P31
    -   多字节字符常量的前面有一个L，那么它就是宽字符常量

#### 二、枚举类型

-   枚举类型就是指它的值为符号常量而不是字面值的类型
-   声明枚举类型:`enum Jar_Type { CUP, PINT, QUART }`
-   声明枚举类型的变量：`enum Jar_Type mikl_jug;`
-   匿名枚举类型声明
    - 例子：
    ```
    enum { CUP, PINT, QUART }
        mikl_jug;
    ```
-   枚举类型实际上是整型方式存储，CUP是0，PINK是1
-   同时也可以给符号名赋值，如果某个符号名赋值了，但下一个没赋值，那么这个没赋值的符号名就比上一个赋值了的符号名的值大1

### 3.1.2 浮点类型

-   非整数或数远远超出了计算机整数所能表达的范围，可以用浮点数的形式存储
-   浮点数通常以一个小数以及一个以某个假设数为基数的指数组成
-   包括float、double、long double，表示单精度、双精度、扩张精度
-   长度比较：`float >= double >= long double`
-   所有浮点至少能容纳从`10E-37`到`10E37`之间的任何值
-   float.h定义了浮点数家族的最大值、最小值
-   浮点字面值总是写成十进制的形式，必须有小数点或一个指数，或两个都有
-   浮点数字面值在缺省情况下都是double，除非跟了L或l（long double）和F或f（float）

### 3.1.3 指针

-   每个内存位置都由地址唯一确定并引用
-   指针只是地址的另一个名字
-   指针变量就是一个其值为另外一个（一些）内存地址的变量

#### 一、指针常量

-   指针常量与非指针常量在本质上是不同的
-   通过操作符获得一个变量的地址而不是直接把它的地址写成字面值常量的形式
-   指针常量表达式为字面值的形式几乎没有用处，所以C内部并没有特定第定义这个概念
-   例外：NULL指针，它可以用零值来表示

#### 二、字符串常量

-   C不存在字符串类型，但C提供了字符串常量
-   字符串的概念：以NUL字节结尾的0个或多个字符
-   字符串通常存储在字符数组中
-   字符串内部不能有NUL字节
-   字符串常量的书写方式是用一对双引号包围一串字符`"Hello"`
-   字符串常量（不像字符常量）可以是空的，但是依然有NUL字节终止
-   K&R C的字符串常量
    -   具有相同值的不同字符串常量在内存中是分开存储的
    -   编译器允许程序修改字符串常量
-   ANSI C的字符串常量
    -   对一个字符串常量进行修改，其效果未定义
    -   它允许编译器把一个字符串常量存储于一个地方
    -   修改字符串常量很危险
    -   许多ANSI编译器不允许修改字符串常量
    -   如果需要修改字符串，请把它存于数组中
-   字符串常量会生成一个“指向字符的常量指针”
-   字符串常量出现在表达式中，表达式所使用的值是字符存储的地址
-   把字符串常量赋给一个“指向字符的指针”
-   不能把字符串常量赋给一个字符数组，因为字符串常量的直接值是一个指针，不是这些值本身

---

## 3.2 基本声明

-   在声明整型变量时，如果声明中已经至少有了一个其他的说明符，关键字int可以省略`unsigend short int a;`和`unsigned short a;`是相等的
-   signed一般只用于char，因为其他类型在缺省情况下都是有符号数
-   相等的整型声明：
    -   表格：
    
    signed | unsigend
    ---|---
    `short`、`signed short`、`short int`、`signed short int` |  `unsigned short`、`unsigned short int`
    `int`、`signed int`、`sigend` | `unsigned int`、`unsigned`
    `long`、`signed long`、`long int`、`signed long int` | `unsigend long`、`unsigned long int`

### 3.2.1 初始化

### 3.2.2 声明简单数组

-   编译器并不检查程序对数组下标的引用是否在数组的合法范围之内

### 3.2.3 声明指针

-   声明指针应该`int *a;`而不应该`int* a;`
-   因为在`int* b,c,d;`会让人误以为b、c、d都是指针，其实这里只有b是指针，应该为`int *b,*c,*d;`

### 3.2.4 隐式声明

-   函数如果不显示地声明并返回值的类型，默认返回整型
-   旧风格声明函数的形式参数，如果忽略了参数的类型，默认为整型
-   编译器能得到足够信息，推断出一个语句是一个声明时，如果缺少类型名，会假设为整型
-   例子 P37

---

## 3.3 typedef

-   typedef机制允许你为各种数据类型定义新名字
    -   例子：
    ```c
    typedef char *ptr_to_char;   //ptr_to_char作为指向字符的指针类型的新名字
    ptr_to_char a;   //a是一个指向字符的指针
    ```

-   `#define`不法正确处理指针类型
    -   例子：
    ```c
    # define d_ptr_to_char  char *
    d_ptr_to_char a,b;  //这里只有a是字符指针，而b只是字符
    ```

-   复杂的类型名，如函数指针和指向数组的指针，使用typedef更合适

---

## 3.4 常量

-   const关键字声明常量，`int const a;`和`const int a;`都可以
-   常量如何拥有一个值
    -   声明时对它进行初始化，`int const a = 15;`
    -   形参在函数调用时会得到实参的值
-   关于指针（const往前结合）
    -   例子：
    ```c
    int *pi;  //普通的指向整型的指针
    int const *pci;  //指向整型常量的指针
    int * const cpi;  //指向整型的常量指针
    int const * const cpci;  //指向整型常量的常量指针
    ```
-   `#define`也可以创建名字常量`#define MAX 50`和`int const max = 50`一样

---

## 3.5 作用域

-   标识符的作用域就是程序中该标识符可以被使用的区域
-   4种作用域：文件作用域、函数作用域、代码块作用域、原型作用域
-   标识符声明的位置决定它的作用域

### 3.5.1 代码块作用域

-   花括号之间的所有语句称为一个代码块
-   任何在代码块开始位置声明的标识符都具有代码块作用域
-   代码块嵌套时，标识符同名，内层标识符隐藏外层标识符
-   `k&R C`函数形参作用域开始于形参的声明处，位于函数体外，局部变量可以隐藏形参
-   `ANSI C`形参作用域为函数最外层的那个作用域（整个函数体），局部变量不可能隐藏形参

### 3.5.2 文件作用域

-   代码块之外声明的标识符具有文件作用域
-   文件作用域：表示从标识符声明处起到源文件结尾都是可以访问的
-   文件中定义的函数名也具有文件作用域
-   `#include`包含到其他文件中的声明就好像直接写在那些文件中一样，它们的作用域不局限于头文件的文件文件尾

### 3.5.3 原型作用域

-   原型作用域只适用于在函数原型中声明的参数名
-   原型中的参数名不必与函数定义中的参数名匹配

### 3.5.4 函数作用域

-   函数作用域只适合于语句标签
-   语句标签用于goto语句
-   函数作用域可以简化为一条规则：一个函数中的所有语句标签必须唯一

---

## 3.6 链接属性

-   标识符的链接属性决定如何处理在不同文件中出现的标识符
-   标识符的作用域和它的链接属性有关
-   3种：external、internal、none
-   没有链接属性的标识符(none)：总是当作独立的个体
-   internal：同一个源文件内的所有声明都是指向同一个实体
-   external：无论声明多少次，位于几个源文件都是表示同一个实体
-   函数定义中的函数调用a，a的链接属性是external，它实际链接到其他文件所定义的函数，或某个函数库

<br/>

-   关键字`extern`和`static`用于声明中修改标识符的链接属性
-   具有external链接属性的标识符，加上static，变为internal
-   static只对缺省属性为external的声明才会有改变链接属性的效果
-   extern为一个标识符指定external链接属性
-   extern用于标识符的第1次声明时，它指定标识符具有external链接属性；用于标识符的第2次或以后的声明时，不会改变第一次声明所指定的链接属性
    -   例子：
    ```c
    static int i;  //声明1
    int func()
    {
        extern int i; //不修改由声明1所指定的变量i的链接属性
    }
    ```
    
---

## 3.7 存储类型

-   变量的存储类型是指存储变量值的内存类型：普通内存、运行时堆栈、硬件寄存器
-   存储类型决定变量何时创建、何时销毁和值保持多久
-   变量的缺省存储类型取决于它的声明位置
    -   代码块之外缺省：静态内存，称为静态（static）变量
    -   代码块内部缺省：堆栈中，称为自动（auto）变量
-   在代码块内部声明的变量，加上`static`，自动变为静态（修改变量的存储类型不代表修改变量的作用域）
-   形式参数不能声明为静态
-   `register`可以用于自动变量的声明，提示应该存储于硬件寄存器中，称为寄存器变量，但编译器不一定理睬
-   可以把函数的形式参数声明为寄存器变量
-   寄存器变量的创建和销毁时间和自动变量相同，但需要做一些额外工作：恢复先前存储的值

### 初始化

-   静态变量的初始化可以把初始化的值放在程序执行变量将会使用的位置，不显示地指定其初始值，静态变量将初始化为0
-   动态变量没有缺省值，如果不显示初始化，那么它们的值总是垃圾

---

## 3.8 static关键字

-   static的作用
    -   对于函数定义或代码外之外的变量声明：链接属性`external--->internal`，存储类型和作用域不受影响
    -   对于代码块内部变量声明：存储类型`自动变量--->静态变量`，链接属性和作用域不受影响

-   extern的作用
-   -   对于代码块内部变量:链接属性`none--->external`，存储类型`自动变量--->静态变量`，说明它所引用的是个全局变量而非局部变量（变量声明可能在别的源文件中）

---

## 3.9 作用域、存储类型示例

-   对于函数，存储类型并不是问题，因为代码总是存储在静态内存中

---

## 3.10 总结

-   如果一个变量声明与代码块内部，在它前面添加一个`extern`将使它引用的是全局变量而非局部变量（有可能是别的源文件中的）
-   具有external链接属性的实体总是具有静态存储类型
-   作用域、链接属性和存储类型总结
    -   表：
   
    变量类型 | 声明的位置 | 是否存储于堆栈 | 作用域 | 如果声明为static | 如果声明为extern
    ---|---|---|---|---|---|
    全局 | 所有代码块之外 | 否 | 从声明处到文件尾 | 不允许从其他源文件访问，变为internal | --- |
    局部 | 代码块起始处 | 是 | 整个代码块 | 变量不存储于堆栈中，它的值在程序整个执行期一直保持 | 引用的是全局变量而非局部变量
    形式参数 | 函数头部 | 是 | 整个函数 | 不允许 | --- |

---

## 3.12 编程提示的总结

-   除了实体的具体定义位置外，在它的其他声明位置都要使用`extern`关键字

---

# 第5章 操作符和表达式

## 5.1 操作符

### 5.1.1 算数操作符

-   1.`+ - * / %`
-   2.`%`只能用于整数类型

### 5.1.2 位移操作符


-   1.`<<`左移操作，移出界的丢弃
-   2.`>>`右移，左边移入新位时有两种方案
    -   a. 逻辑移位：左边移入的用0填充
    -   b. 算数移位：左边移入的由原先的符号位决定
-   3.位移操作符的两个操作数都必须是整形类型
-   4.无符号值都是逻辑位移，有符号值由编译器决定
-   5.`a << -5`这个位移的值是不可预测的

### 5.1.3 位操作符

-   1.AND、OR、XOR; `&、|、^`

### 5.1.4 赋值

-   1.赋值是表达式的一种，而不是某种类型的语句（没有赋值语句）
-   2.赋值是表达式，所以它就具有一个值，赋值表达式的值就是左操作数的新值，可以作为其他赋值操作符的右操作数，如`a = x = y + 3`,即`a = ( x = y + 3 )`
-   3.`a = x = y + 3`认为a和x被赋予相同的值的说法是错误的，因为可能变量类型不同，比如x是字符型变量，那么y+3的值就会被截去一段，所以以下代码是错误的（具体参照P70）
    - a.   
        ```
        char ch;
        ...
        while( ( ch = getchar() ) != EOF )...
        ```
-   4.复合赋值符：`+=、<<=、&=`等等，`a += expression`等于`a += a + ( expression )`

### 5.1.5 单目操作符

`!、++、-、&、sizeof、~、--、+、*、(类型)`

-   1.`~`:按位取反
-   2.`-`：负值
-   3.`+`:正值，与`-`相对
-   4.`&`:取地址
-   5.`*`:间接访问操作符，与指针一起用
-   6.`sizeof`:操作数的类型长度，字节为单位;`sizeof (int)`、`sizeof x`;当操作数为数组名时，返回数组的长度，以字节为单位;判断表达式的长度不需要对表达式求值，所以`sizeof( a = b + 1 )`并没有向a赋值
-   7.`(类型)`：强制类型转换
-   8.`++和--`:操作数必须是个“左值”；前缀形式：操作数的值被增加，表达式是操作数增加后的值；后缀形式：操作数的值被增加，表达式是增加前的值；增值操作符都是复制一份变量值的拷贝，用于表达式的值正式这份拷贝，前缀后缀只是复制的时间不一样，因此`++a = 10`是错误的，因为不能向一个拷贝值进行赋值（P73）

### 5.1.6 关系操作符

`>   >=   <   <=   !=   ==`

-   这些操作符产生的结果都是整型值1或0，不是布尔值

### 5.1.7 逻辑操作符

`&&   ||`

-   短路求值

### 5.1.8 条件操作符

`expression1 ? expression2 : expression3`

### 5.1.9 逗号操作符

`,`

-   逗号操作符将多个表达式分隔开来，这些表达式自左向右逐个进行求值
-   `if( b + 1, c / 2, d > 0)`这里看的是`d > 0`

### 5.1.10 下标引用、函数调用和结构函数

-   C的下标值总是从0开始，并且不会对下标值进行有效性验证
-   除了优先级不同外，下标引用操作和间接访问表达式是等价的
    -   `array[ 下标 ]`和`*( array + ( 下标 ) )`
-   `.`和`->`操作符用于访问一个结构的成员，当你拥有一个指向结构体的指针而不是结构体本身时，使用`->`访问它的成员

---

## 5.2 布尔值

-   C不具备显示的布尔类型，使用整数代替
-   零是假，任何非零值为真
-   注意这类写法，flag为1以外的其他非零值，这个if语句也是不执行的：
    - a.
    ```
    #define FALSE 0
    #define TRUE 1
    if( flag == TRUE)
    ```
---

## 5.3 左值和右值

-   左值就是那些能够出现在复制符号左边的东西，右值同理
-   “表达式不能作为左值”这句话是错的：`a[ b + 10 ] = 0`中的左值就是表达式，这些操作符包括间接访问操作符和下标引用

---

## 5.4 表达式求值

### 5.4.1 隐式类型转换

-   整型升级：字符型加法运算时，会提升为普通整型

### 5.4.2 算术转换

-   寻常算术转化（P80）

### 5.4.3 操作符的属性

-   复杂表达式的求值顺序3个决定因素：操作符的优先顺序、操作符的结合性（`L-R`、`R-L`）、操作符是否控制执行的顺序（`&&`、`||`）
-   操作符优先级表 p81

### 5.4.4 优先级和求值的顺序

-   `c + --c`根据编译器的不同会产生不同的结果

---

## 5.5 总结

-   `&&`、`||`和`?:`对求值过程施加控制
-   逗号操作符，整个表达式的值是最右那个子表达式的值
-   各个不同类型之间的值不能直接进行运算，除非其中一个的操作数转换为另一个操作数的类型（寻常算术转换）
-   表达式的结果如果依赖于求值的顺序，那么它在本质上就是不可移植的，应该避免使用（P86）
-   不要混用整型和布尔型值

---

# 第6章 指针

## 6.1 内存和地址

-   字节：8个位
-   字：许多机器以字为单位存储整数，每个字一般由2个或4个字节组成
-   尽管一个字包含了4个字节，它仍然有一个地址，或是最左边那个字节或是最右边那个字节
-   边界对齐
-   内存中的每个位置都由一个独一无二的地址标识；内存中的每个位置都包含一个值

---

## 6.2 值和类型

-   不能简单地通过检查一个值的位来判断它的类型，为了判断值的类型，必须观察程序中这个值的使用方式

---

## 6.3 指针变量的内容

-   一个变量的值就是分配给这个变量的内存位置所存储的数值，要区分与指针的内容

---

## 6.4 间接访问操作符

-   通过一个指针访问它所指向的地址的过程称为间接访问或解引指针，使用`*`

---

## 6.5 未初始化和非法的指针

    ```
    int *a;
    ...
    *a =12;
    ```
    
-   是错误的，因为没有对a进行初始化

---

## 6.6 NULL指针

-   要使一个指针变为NULL，你可以给它赋一个零值
-   为了测试一个指针变量是否为NULL，你可以将它与零值进行比较
-   对一个NULL指针进行解引用操作是非法的

---

## 6.7 指针、间接访问和左值

-   间接访问操作符所需要的操作数是一个右值，但这个操作符所产生的结果是个左值

---

## 6.8 指针、间接访问和变量

-   `*&a = 25`和`a = 25`从结果上来说是一样的

##  6.9 指针常量

-   `*100 = 25`是非法的
-   `*(int *)100 = 25`是合法的
-   指针常量通常用来根据已经设备的设备地址来访问设备

---

## 6.10 指针的指针

-   声明：`int **c`
-   声明为register的指针变量，不可以再使用&取址（P99）

---

## 6.11 指针表达式

-   cp作为字符指针，`++cp`是不能成为左值的，这个运行结果的返回值是原cp指向地址的下1个地址
-   cp作为字符指针，`cp--`是不能成为左值的，这个运行结果的返回值是原cp指向的地址
-   对于`*++cp`、`*cp++`、`++*cp`参考P103
-   由于后缀`++`的优先级高于`*`,所以`*cp++`分为三步：
    -   1. ++操作产生cp的一份拷贝
    -   2. 然后++操作符增加cp的值
    -   3. 最后，在cp的拷贝上执行间接访问操作
-   `++*++cp`、`++*cp++`参考P104

---

## 6.12 实例

---

## 6.13 指针运算

-   指针加上一个整数的结果是另一个指针，如果p是个指向float的指针，那么p+1就指向下一个float

### 6.13.1 算术运算

-   C的指针算术运算只限于两种形式：1.`指针 +/- 整数`；2.`指针 - 指针`
-   `指针 +/- 整数`
    -   标准定义这种形式只能用于指向数组中某个元素的指针
    -   这类表达式的结果类型也是指针
-   `指针 - 指针`
    -   只有当两个指针都指向同一个数组中的元素时，才允许一个指针减去另一个指针
    -   结果类型是ptrdiff_t，一种有符号整数类型
    -   减法运算的值时两个指针在内存中的距离，以数组元素的长度为单位，不是以字节为单位
    -   ptrdiff_t = 实际内存差 / 数组类型长度
    -   存在`p1 - p2 = 负数`的情况，只要两个指针都指向同一个数组的元素

### 6.13.2 关系运算

-   `<      <=      >       >=`
-   前提是指向同一个数组中的元素
-   比较表达式将告诉你哪个指针指向数组中更前或更后的元素

---

## 6.14 总结

-   无法通过值的位模式来判断它的类型，类型是通过值的使用方式隐形确定的
-   声明一个指针变量并不会自动分配任何内存，在指针执行间接访问前，指针必须进行初始化，或使它指向现有的内存，或给它分配动态内存
-   NULL指针执行间接访问操作的后果因编译器而异，常见后果为：返回内存位置零的值或终止程序
-   指针常量：通过把整型值强行转换为指针类型来创建它
-   指针加法运算，如果指针指向数组最后一个元素后面的那个内存位置仍是合法的
-   

---

## 6.15 警告

-   错误地对一个未初始化的指针变量进行解引用
-   错误地对一个NULL指针进行解引用
-   向函数错误地传递NULL指针
-   未检测到指针表达式的错误，从而导致不可预料的结果
-   对一个指针进行减法运算，使它非法地指向了数组第1个元素的前面的内存位置
---

# 第7章 函数

## 7.1 函数定义

-   函数的定义就是函数体的实现
-   函数声明出现在函数被调用的地方，函数声明向编译器提供函数的相关信息，用于确保函数被正确地调用
-   存根(stub)：应该就是一个空函数。编写这类存根，或者说为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性，以便于你编译和测试程序的其他部分
    ```
    function_name()
    {
    }
    ```
-   过程类型的函数：没有返回值
-   真函数：从表达式内部调用的，必须返回一个值，用于表达式的求值

---

## 7.2 函数声明

### 7.2.1 原型

-   第2种向编译器提供函数信息的方法是使用函数原型（第1种应该是函数定义）
-   使用原型最方便的方法是把原型置于一个单独的文件，使用`#include`指令包含该文件
-   `int func( int i );`中`;`区分了函数原型和函数定义的起始部分
-   原型中的参数名字并不是必需的
-   函数原型具有文件作用域，所以原型的一份拷贝可以作用于整个源文件
-   函数原型必须与函数定义匹配
-   `int *func()`不能表示一个没有参数的函数的原型，因为旧式风格的有参函数是可以这样声明的，一个没有参数的函数原型应该写成`int *func(void)`

### 7.2.2 函数的缺省认定

-   当程序调用一个无法见到原型的函数时，编译器认为该函数返回一个整型值
-   所有的函数都应该具有原型，尤其是那些返回值不是整型的函数
-   如果编译器认定函数返回一个整型值，它将产生整型数指令操作这个值（如果返回的不是整型值，那将会出错，例子参考P121）

---

## 7.3 函数的参数

-   1.所有参数均以“传值调用”方式进行传递，这意味着函数将获得参数值的一份拷贝
-   2.数组并不会得到一份拷贝，而是得到数组首地址的一份拷贝，这个行为被称为“传值调用”，因为数组名的值实际上是一个指针，传递给函数的就是这个指针的一份拷贝
-   3.记住两个规则：
    -   a.传递给函数的标量参数是传值调用的
    -   b.传递给函数的数组参数在行为上就像它们是通过传址调用的那样
-   4.在函数参数声明中，声明数组参数时不指定它的长度是合法的，因为函数并不为数组元素分配内存

---

## 7.4 ADT和黑盒

-   C可以用于设计和实现抽象数据类型（ADT，abstract data type），也被称为黑盒设计
-   抽象数据类型的基本想法：模块具有功能说明和接口说明
-   限制对模块的访问是通过`static`关键字的合理使用实现的，它可以限制那些并非接口的函数和数据的访问

---

## 7.5 递归

-   C通过运行时堆栈支持递归函数的实现，递归函数就是直接或间接调用自身的函数。

### 7.5.1 追踪递归函数

-   追踪一个递归函数执行过程的关键是理解函数中所声明的变量是如何存储的，因此可以通过画堆栈图来理解（参考P128的例子）

### 7.5.2 递归与迭代

-   1.递归函数调用将涉及一些运行时开销
    -   a.参数必须压到堆栈中
    -   b.为局部变量分配内存空间
    -   c.寄存器的值必须保存
-   2.因此递归函数的开销是十分大的
-   3.尾部递归：当一个函数在递归调用返回之后不再执行任何任务，这样的递归函数叫尾部递归
-   4.尾部递归可以很方便地转换成一个简单循环，完成相同任务，但开销更小
-   5.迭代实现往往比递归实现效率更高，但代码可读性稍差
-   6.如果一个问题相当复杂，难以用迭代形式实现时，此时递归实现的简便性可以补偿它所带来的运行时开销

---

## 7.6 可变参数列表

-   1.宏是由预处理器实现的
-   2.可变参数列表是通过宏来实现的，这些宏定义于stdarg.h头文件，它是标准库的一部分
-   3.分别有一个类型`va_list`和三个宏`va_start`、`va_arg`和`va_end`
-   4.参数列表中的省略号提示此处可能传递数量和类型未确定的参数，编写函数原型时，也要使用同样的记法
-   5.可变参数必须从头到尾按顺序逐个访问，半途终止是可以的，但不能一开始就访问参数列表中的中间的参数
-   6.由于可变参数部分没有原型，可变参数传递给函数的值都将执行缺省参数类型的提升（//TODO 不明白什么意思）
-   7.这些宏存在两个基本限制，是由“一个值的类型无法简单地通过检查它的位模式来判断”导致的
    -   a.这些宏无法判断实际存在的参数的数量
    -   b.这些宏无法判断每个参数的类型
-   8.要回答`7.`中的两个问题，就必须使用命名参数
        

```c
#include <stdarg.h>

float
average ( int n_values, ...)
{
    //用于访问参数列表的未确定部分
    va_list var_agr;
    int count;
    float sum = 0;
    
    //使用va_start来初始化，第1个参数是va_list变量的名字，第2个参数是省略号前最后一个有名字的参数，初始化过程把var_arg变量指向可变参数部分的第1个参数
    va_start( var_agr, n_values );
    
    for( count =0; count < n_values; count +=1 ){
        //访问参数，第1个变量va_list变量，第2个变量，参数列表中下一个参数的类型。va_arg返回这个参数的值，并使var_arg指向下一个可变参数
        sum += va_arg( var_arg, int );
    }
    //访问完毕最后一个可变参数之后，需要调用va_end
    va_end( var_arg );
    
    return sum / n_values;
}
```

---

## 7.7 总结

-   1.参数列表有两种可以接受的形式：K&R C风格和新风格
-   2.函数声明也有两种可以接受的形式：
    -   a.K&C C每个没有参数列表，只声明了返回值的类型
    -   b.新风格又称为函数原型，包含了参数列表的声明
-   3.对于那些没有原型的函数，传递给函数的实参将进行缺省参数提升
    -   a.char和short转换为int
    -   b.float转换为double

---

# 第8章 数组

## 8.1 一维数组

### 8.1.1 数组名

-   数组名的值是一个指针常量，也就是数组第1个元素的地址，int数组的数组名就是“指向int的常量指针”
-   数组和指针是不相同的，不同的特征：
    -   1.数组具有确定数量的元素，而指针只是一个变量值
    -   2.数组名只有在表达式中使用，编译器才会产生一个指针常量
-   两种场合下，数组名并不用指针常量来表示
    -   1.`sizeof`：返回整个数组的长度
    -   2.`&`:指向数组的指针，而不是指向某个指针常量的指针，也就是说若array为数组名，那么`array == &array`,但也存在区别，看[数组名a和&a的区别](http://blog.csdn.net/wanwenweifly4/article/details/6424058)
-   考虑下面例子：
    -   a.   
    ```c
    int a[10];
    int b[10];
    int *c;
    ...
    c = &a[0];  //和 c = a 是一样的；b = a 是非法的； a = c是非法的，a是常量不能修改
    ```

### 8.1.2 下标引用

-   除了优先级外，下标引用和间接访问完全相同
    -   如下是相同的：
    ```c
    array[ subscript ]
    * ( array + ( subscript ) )
    ```
    -   例子：
    ```c
    int array[10];
    int *ap = array + 2;
    
    ap[0]; //对等*(ap+(0))，即array[2]
    *ap+6; //array[2]+6
    ap[-1]; //array[1]
    ```
-   C的下标检查所涉及的开销比你刚开始想象的要多
-   `2[array]`是合法的，等于`( 2 + ( array ) )`，就是`*( array + 2 )`,也就是`array[2]`

### 8.1.3 指针与下标

-   下标绝对不会比指针更有效率，但指针有时会比下标更有效率
-   例子 P145

### 8.1.4 指针的效率

-   指针有时比下标更有效率，前提是它们被正确地使用
-   不要为了效率上的细微差别而牺牲可读性
-   可以对指针使用寄存器变量，但是指针必须被声明为局部变量

#### 结论

-   当你根据某个固定数目的增量在一个数组中移动时，使用指针变量比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这点表现更为突出
-   声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高
-   如果你可以通过测试一些已经初始化并经过调整的内容来判断是否应该终止循环，那么你就不需要使用一个单独的计数器
-   那些必须在运行时求值的表达式较之诸如&array[SIZE]或array+SIZE这样的常量表达式往往代价更高

### 8.1.5 数组和指针

-   指针和数组并不是相等的
-   声明一个数组时，为数组保留内存空间，再创建数组名，它的值是一个常量，指向这段空间的起始位置
-   声明一个指针变量时，只为指针本身保留内存空间，并不为它分配内存空开，它如果是自动变量，它甚至不会被初始化

### 8.1.6 作为函数参数的数组名

-   传递给函数的是一份该指针的拷贝
-   所有的参数都是通过传值方式传递的
-   无论函数对参数（指针）如何进行修改，都不会修改调整程序的指针实参本身（但可能修改它所指向的内容）

### 8.1.7 声明数组参数

-   `int func( char *string )`和`int func( char string[] )`在当前的上下文环境中是相等的，但使用指针声明更为准确
-   对函数中参数指针使用`sizeof string`的值是指向字符的指针的长度，而不是数组的长度
-   数组参数可以与任何长度的数组匹配，这种实现方式使函数无法知道数组的长度

### 8.1.8 初始化

-   `int vector[5] = { 1, 2, 3, 4, 5 };`

#### 静态和自动初始化

-   初始化方式：取决于它们的存储类型
    -   静态内存中的数组只初始化1次，未初始化时，自动设为零
    -   自动变量，缺省情况下未初始化
-   对于那些非常庞大的数组，它的初始化时间可能非常可观
-   需要权衡利弊，数组的初始化局部于一个函数（或代码块）时，是不是值得，如果不值得，就把数组声明为static

### 8.1.9 不完整的初始化

-   初始化值的数组和数组元素的数目并不匹配
-   只允许省略最后几个初始值（局部变量也可以，如果最后没有初始化，那么就初始化为0）

### 8.1.10 自动计算数组长度

-   如果声明中并未给出数组的长度，编译器就把数组的长度设置为刚好能容纳所有的初始值的长度

### 8.1.11 字符数组的初始化

-   ```char m[] = { `H`, `I` };```
-   `char m[] = "HI";`,尽管这个看上去是一个字符串常量，实际上不是
    -   例子：
    ```c
    char m1[] = "HELLO"; //初始化一个字符数组的元素
    char *m2 = "HELLO"; //真正的字符串常量
    ```

---

## 8.2 多维数组

### 8.2.1 存储顺序

-   多维数组的元素存储顺序按照最右边的下标率先变化的原则，称为行主序
-   `int matrix[6][10]`是6行10列还是10行6列，都对，只要每次都坚持使用一种方法，这两种解释都是可行的，但并不会改变数组的存储顺序

### 8.2.2 数组名

### 8.2.3 下标 

-   `matrix[x][y]`等于`*( *( matrix + x) + y )`
-   `&matrix[0][0]`等于`matrix`
-   `&matrix[x]`等于`matrix+x`
-   `matrix[x]`等于`*(matrix+x)`
-   `&matrix[x][y]`等于`*(matrix +x) + y`
-   `matrix[4,3]`等于`matrix[3]`，因为逗号表达式是最后一个子表达式的值 

### 8.2.4 指向数组的指针

-   例子：
    ```c
    int v[10], *vp = v;  //合法
    int m[3][10], *mp = m; //非法，mp是指向整型的指针，而m是一个指向整型数组的指针
    int (*p1)[10] = m;  //合法
    int (*p2)[] = m;  //应该避免这种类型的声明，不能执行指针运算
    ```
    
### 8.2.5 作为函数参数的多维数组

-   例子：
    ```c
    int matrix[3][10];
    ...
    func2( matrix );
    
    //那么func2的声明可以是：
    void func2( int (*mat)[10] );
    void func2( int mat[][10] );
    //但以下方式是错误的
    void func2( int **mat ); //指向整型指针的指针和指向整型数组的指针并不是一回事
    ```

### 8.2.6 初始化

-   初始化多维数组时，数组的存储顺序非常重要
-   初始化例子：`int m[2][3] = { 1, 2, 3, 4, 5, 6};`
-   初始化也可以是：
    -   例子：
    ```c
    int m[2][5] = {
        { 1, 2, 3, 4, 5},
        { 6, 7, 8, 9, 10}
    };
    ```
-   如果使用了这些花括号，每个子初始化列表都可以省略尾部的几个初始值，每一维的初始列表都各自都是一个初始化列表

### 8.2.7 数组长度自动计算

-   数组长度只有第1维才能根据初始化列表缺省地提供，其余的几个维必须显示写出
-   如果别的维也想缺省，编译器是允许这样做的，但是每个列表中的子初始值列表至少有一个要以完整的形式出现（不得省略末尾的初始值）
-   如果我们要求除第1维之外的其他维的大小都显示提供，所有的初始值列表都无需完整

---

## 8.3 指针数组

-   声明指针数组`int *api[10]`，api是数组名，数组元素是整型指针；区别与二维数组`int (*api)[10]`，api是指针名，指向的是一个长度为10的整型数组
-   区别：
    -   字符串以矩阵存储还是以指针常量方式存储（需要两种方式占用内存空间方面的区别，图在P164）
    ```c
    //指针常量
    char const *keyword1[] = {
        "do",
        "for"
    }
    //矩阵,每行必须与最长字符串的长度一样，不需要指针
    char const keyword2[][5] = {
        "do",
        "for"
    }
    ```
-   哪种更好？
    -   字符串长度差不多：矩阵，因为无需使用指针
    -   字符串长度千差万别：指针数组

---

## 8.4 总结

-   `sizeof`返回整个数组占用的字节而不是指针的字节；`&`返回一个指向数组的指针，而不是一个指向数组第1个元素的指针的指针（形参是指针，但是传入的数组的情况除外）
-   数组形参既可以声明为数组，也可以声明为指针，这两种声明形参只有当它们作为函数的形参时才相等
-   如果初始化列表包含的值的个数少于数组元素的个数，数组最后几个元素就用缺省值进行初始化

---

## 8.5 警告的总结

-   当访问多维数组时，误用逗号分隔下标，`a[3,5]`其实是`a[5]`
-   在一个指向未指定长度的数组的指针上执行指针计算`int (*p)[] = matrix`

---

## 8.6 编程提示的总结

-   源代码的可读性几乎总是比程序的运行时效更为重要
-   只要有可能，函数的指针形参都应该声明为const
-   对维数组初始化使用多层花括号能提高可读性

---

# 第9章 字符串、字符和字节

-   C语言没有显示的字符串数据类型
-   字符串以字符串常量的形式出现或者存储于字符数组中，字符串常量适合用于不会对它们进行修改的字符串

## 9.1 字符串基础

-   字符串就是一串零个或多个字符，并且以一位模式全为0的NUL字节结尾，但它本身不是字符串的一部分，所以字符串的长度并不包括NUL字节
-   `string.h`包含了字符串函数所需要的原型和声明，但是并非必须

---

## 9.2 字符串长度

-   字符串的长度就是它所包含的字符个数，不包括NUL
-   `size_t strlen( char const *string )`
-   返回类型为`size_t`，定义在头文件`stddef.h`，是一个无符号整数类型
-   `if( strlen( x ) - strlen( y ) >= 0)`这条语句永远是true，因为strlen返回的是无符号数，而无符号数是绝对不可能是负的
-   `if( strlen( x ) >= 10 )`与`if( strlen( x ) -10 >= 0 )`不相等，原因与上同，可以将返回值强制转换为int就可以解决这个问题
-   标准库函数有时是用汇编语言实现的，目的就是充分利用某些机器所提供的字符串操作指令，从而追求最大的速度

---

## 9.3 不受限制的字符串函数

### 9.3.1 复制字符串

-   `char *strcpy( char *dst, char const *src);`
-   由于dst参数是需要修改的，所以不能使用字符串常量
-   必须保证目标字符数组的空间足以容纳需要复制的字符串。如果超长，多余的字符仍然被复制，会覆盖原先存储于数组后面的内存空间的值

### 9.3.2 连接字符串 

-   `char *strcat ( char *dst, char const *src);`
-   如果src和dst的位置发生重叠，其结果是未定义的

### 9.3.3 函数的返回值

-   strcpy和strcat返回第1个参数的一份拷贝，就是一个指向目标字符数组的指针
-   所以这些函数都可以嵌套地调用这些函数

### 9.3.4 字符串比较

-   `int strcmp( char const *s1, char const *s2 );`
-   两个字符串对应的字符逐个进行比较，直到发现不匹配为止
    -   最先不匹配的字符较“小”的那个字符所在的那个字符串被认为“小于”另外一个字符串
    -   其中一个字符串是另一个字符串前面一部分，那么它也被认为“小于”另外一个字符串
-   s1小于s2，返回一个小于零的值（不一定是-1）；s1大于s2，返回一个大于零的值（不一定是1）；两个字符串相等，则函数返回零

---

## 9.4 长度受限的字符串函数

-   这些函数接受一个现实的长度参数
-   如果源参数和目标参数发生重叠，strcpy和strncat的结果就是未定义的
```c
char *strncpy( char *dst, char const *src, size_t len );
char *strncat( char *dst, char const *src, size_t len );
int *strncmp( char const *s1, char const *s2, size_t len );
```
-   如果strlen(src)的值小于len，dst数组就用额外的NUL字节填充到len长度
-   如果strlen(src)的值大于或等于len，那么只有len个字符被复制到dst中，注意！它的结果不会以NUL字节结尾
-   在使用不受限的函数之前，你首先必须确定字符串实际上是以NUL字节结尾的，但长度受限函数不需要
-   strncat总是在结果字符串后面添加一个NUL字节，并且不会像strcpy用NUL字节进行填充

---

## 9.5 字符串查找基础

### 9.5.1 查找一个字符

```c
/*
在字符串str中查找字符ch第一次出现的位置，找到后返回一个指向该位置的指针
如果不存在，则返回NULL
*/
char *strchr ( char const *str, int ch);
//与strchr功能相似，但是是最后一次出现的位置
char *strrchr ( char const *str, int ch);
```

### 9.5.2 查找任何几个字符

```c
/*
查找任何一组字符第1次在字符串中出现的位置
返回一个指向str中第1个匹配group中任何一个字符的字符位置
未匹配，返回NULL
*/
char *strpbrk( char const *str, char const *group );
```

### 9.5.3 查找一个子串

```c
/*
如果s2并没有完整地出现在s1的任何地方，函数返回NULL
如果s2是一个空字符串，返回s1
*/
char *strstr( char const *s1, char const *s2 );
```
-   标准库中并不存在strrstr或strrpbrk

---

## 9.6 高级字符串查找

### 9.6.1 查找一个字符串前缀

-   strspn和strcspan用于在字符串的起始位置对字符计数
-   strspn()从参数str字符串的开头计算连续的字符，而这些字符都完全是group 所指字符串中的字符。简单的说，若strspn()返回的数值为n，则代表字符串s开头连续有n 个字符都是属于字符串group内的字符
```
//返回str起始部分匹配cgroup中任意字符的字符数
size_t strspn( char const *str, char const *group );
//对str字符串起始部分中不与group中任何字符匹配的字符数
size_t strcspn( char const *str, char const *group );

int len1,len2;
char buffer[] = "25,142,330,Smith,J,239-4123";
len1 = strspn (buffer, "0123456789" );  //结果为2，因为只有"25"
len1 = strspn (buffer, ",0123456789" ); //结果为11,因为"25,142,330,"

//计算一个指向字符串中第1个非空白字符的指针
ptr = buffer + strspn( buffer, "\n\r\f\t\v"); 
```

### 9.6.2 查找标记

-   strtok:从字符串中隔离各个单独的称为标记（token）的部分，并丢弃分隔符
```c
char *strtok( char *str, char const *sep)

void print_tokens( char *line )
{
	static char whitespace[] = " \t\f\r\v\n";
	char *token;

	for( token = strtok( line, whitespace ); token !=NULL; token = strtok( NULL, whitespace ) )
	{
		printf("Next token is %s\n", token);
	}
}
```
-   sep参数是个字符串，定义了用作分隔的字符集合
-   strtok找到str的下一个标记，并将其用NUL结尾，然后返回一个指向这个标记的指针
-   它将会修改它所处理的字符串
-   如果strtok函数的第1个参数不是NULL，函数将找到字符串的第1个标记，strtok同时保存它在字符串中的位置
-   如果strtok函数的第1个参数是NULL，函数就在同一个字符串中从这个被保存的位置开始像前面一样查找下一个标记
-   如果字符串内不存在更多的标记，strtok返回一个NULL指针

<br/>

-   你可以在每次调用strtok时使用不同的分隔符集合
-   由于strtok函数保存它所处理的函数的局部状态信息，所以你不能用它同时解析两个字符串，因此，如果for循环的循环体内调用了一个在内部调用strtok函数的函数，程序会失败

---

## 9.7 错误信息

-   当调用一些函数，请求操作系统执行一些功能，如果出现错误，操作系统是 通过设置一个外部的整型变量errno进行错误代码报告的
-   strerror把其中一个错误代码作为参数并返回一个指向用于描述错误的字符串的指针
-   `char *strerror ( int error_number );`

---

## 9.8 字符操作

-   标准库包含了两组函数用于操作单独的字符：对字符分类和转换字符
-   ctype.h

### 9.8.1 字符分类

-   每个分类函数接受一个包含字符值的整型参数
-   函数测试这个字符并返回一个整型值
-   `isspace`、`isupper`等函数
-   字符分类函数  表 P184

### 9.8.2 字符转换

-   转换函数把大写字母转换为小写字母，或反过来

```
int tolower( int ch );
int toupper( int ch );
```

-   如果参数并不是一个处于适当大小写状态的字符（不是大写或小写字母），函数将不修改参数直接返回
-   直接测试或操纵字符将会降低程序的可移植性

---

## 9.9 内存操纵

-   它们的操作与字符串函数类型，但这些函数能够处理任意的字节序列（可以包括NUL）

```c
//length是以字节为单位的
void *memcpy( void *dst, void const *src, size_t length );
void *memmove( void *dst, void const *src, size_t length );
void *memcmp( void const *a, void const *b, size_t length );
void *memchr( void const *a, int ch, size_t length );
void *memset( void *a, int ch, size_t length );
```

-   它们在遇到NUL字节时并不会停止操作
-   memcpy中如果src和dst以任何形式出现了重叠，它的结果是未定义的
-   任何类型的指针都可以转换为void*型指针
-   memmove的行为和memcpy差不多，但它的源和目标操作数可以重叠，它可能比memcpy慢一些，但源和目标参数真的可能存在重叠，就应该使用memmove。原理：把源操作数复制到一个临时位置，这个临时位置不会与源或目标操作数重叠，然后再把它从这个临时位置复制到目标操作数
-   memcmp按照无符号字符逐字节进行比较，函数的返回类型和strcmp一样。如果比较不是单字节的数据如整型或浮点数时就可能出现不可预料的结果
-   memset把从a开始的length个字节都设置为字符值ch

---

## 9.10 总结

-   字符串的长度就是它所包含的字符的数目，不包括NUL
-   strncpy中，如果源字符串比指定长度更长，结果字符串将不会以NUL字节结尾
-   strncat它的结果始终以一个NUL字节结尾

---

## 9.11 警告的总结

-   应该使用有符号数的表达式中使用strlen函数，返回值类型size_t是无符号整型
-   把strcmp函数的返回值当做布尔值进行测试，是错误的
-   把strcmp函数的返回值与1或-1进行比较，是错误的
-   使用strcpy函数产生不以NUL字节结尾的字符串
-   忘了strtok函数将会修改它所处理的字符串
-   strtok函数是不可再入的，即连续几次调用中，即使它们的参数相同，其结果也可能不同

---

## 9.12 编程提示的总结

-   使用字符分类和转换函数可以提高函数的移植性

---

# 第10章 结构和联合

## 10.1 结构基础知识

-   聚合数据类型能够同时存储超过一个的单独数据，如数组和结构
-   结构的值称为它的成员，各个成员可能具有不同的类型，可以通过名字来访问
-   和数组名不同，当一个结构变量在表达式中使用时，它并不能替换成一个指针
-   结构变量属于标量类型，你可以声明指向结构的指针，取一个结构变量的地址

### 10.1.1 结构声明

-   `struct tag { member-list } variable-list;`
-   两个成员列表完全相同的结构体，也是不同的类型
-   声明结构体时可以用typedef创建一种新的类型
    -   例子：
    ```c
    typedef struct {
        int a;
        char b;
    } Simple;
    
    Simple x;
    ```

### 10.1.2 结构成员

-   一个结构的成员的名字可以和其他结构的成员的名字相同

### 10.1.3 结构成员的直接访问

-   结构变量的成员是通过点操作符`(.)`访问的

### 10.1.4 结构成员的间接访问

-   拥有一个指向结构的指针
    -   `struct COMPLEX *cp`
    -   可以`(*cp).f`   
    -   也可以`cp->f`
    -   后者称为`->操作符`，左操作数必须是一个指向结构的指针

### 10.1.5 结构的自引用

```c
//非法
struct SELF_REF1 {
    int a;
    struct SELF_REF1 b;
    int c;
}

//合法
struct SELF_REF2 {
    int a;
    struct SELF_REF2 *b;  //注意这里是指针
    int c;
}

//非法，类型名直到生命的末尾才定义，所以在结构体生命的内部它尚未定义
struct {
    int a;
    struct SELF_REF3 *b;  
    int c;
} SELF_REF3

//合法
struct SELF_REF3_TAG {
    int a;
    struct SELF_REF3_TAG *b;  
    int c;
} SELF_REF3
```

### 10.1.6 不完整的声明

-   相互之间存在依赖的结构，需要使用不完整声明   

```c
struct B;

struct A {
    struct B *partner;
}

struct B {
    struct A *partner;
}
```

### 10.1.7 结构的初始化

-   这些值根据结构成员列表的顺序写出，如果初始列表的值不够，剩余的结构成员将使用缺省值进行初始化

```c
struct INIT_EX {
    int a;
    short b[10];
    simple c;
} x = {
    10,
    { 1, 2, 3 };
    { 25, `x`, 1.9 }
};
```

---

## 10.2 结构、指针和成员

```c
typedef struct {
    int a;
    short b[2];
} Ex2;
typedef struct EX {
    int a;
    char b[3];
    Ex2 c;
    struct EX *d;
} Ex;

Ex x = { 10, "Hi", { 5, { -1,25 } }, 0 };
Ex *px = &x;
```

### 10.2.1 访问指针

-   `px + 1`表达式并不是一个合法的左值
-   右值：如果px指向一个结构数组的元素，这个表达式将指向该数组的下一个结构，但仍然是非法的，因为我们没法分辨内存下一个位置所存储的是这个结构元素之一还是其他东西

### 10.2.2 访问结构体

-   访问结构体：`*px`
-   `*px + 1`是非法的
-   `*(px + 1)`由于x是标量，所以这个表达式实际上是非法的

### 10.2.3 访问结构成员

-   `px->a`和`x.a`相等
-   比较`*px`和`px->a`
    -   a的地址和结构的地址是一样的
    -   尽管两个地址是相等的，但它们的类型不同
    -   `int *pi;   pi = px;`是非法的，因为它们的类型不匹配
    -   `pi = &px->a`是合法的，这个操作之后pi和px具有相同的值，但是类型不同，`*px`结果是整个结构，`*pi`结果是一个单一的整型值

### 10.2.4 访问嵌套的结构

### 10.2.5 访问指针成员

---

## 10.3 结构的存储分配

-   编译器安装成员列表的顺序一个接一个地给每个成员分配内存。只有当存储成员时需要满足正确的便捷对齐要求时，成员之间才可能出现填充的额外内存空间
```c
struct ALIGN {
    char a;
    int b;
    char c;
}
```
-   如果某个机器的整型值长度为4个字节，并且它的起始存储位置必须能够被4整除，那么这个结构体在内存中的存储将如下所示
-   `[a][][][][b, , , ][c][][][]`
-   系统禁止编译器在一个结构体的起始位置跳过几个字节来满足边界对齐要求，因此所有结构的起始存储位置必须是结构中边界要求最严格的数据类型所要求的位置，因此a必须存储于一个能够被4整除的地址
-   sizeof操作符能够得到一个结构的整体长度，包括因边界对齐而跳过的那些字节
-   确定结构体某个成员的实际位置，应该考虑边界对齐因素，可以使用offsetof宏（定义于stddef.h）
-   `offsetof( type, member );`
-   type就是结构的类型，member就是你需要的那个成员名，表达式的结果是一个size_t，表示这个指定成员开始存储的位置距离结构体开始存储的位置偏移几个字节
-   `offsetof( struct ALIGN, b)`的结果是4

---

## 10.4 作为函数参数的结构

-   一般传指针，可以传值，但是效率低
-   向函数传递指针的缺陷在于函数现在可以对调用程序的结构体进行修改，可以使用const来防止
-   `void print_receipt ( register Transaction const * trans)`
-   参数声明为寄存器变量，可以进一步提高指针方案的效率

---

## 10.5 位段

-   位段（bit field）
-   位段的声明和结构类似，但它的成员是一个或多个位的字段，这些不同长度的字段实际上存储于一个或多个整型变量中
-   位段成员必须声明为int、signed int或unsigned int
-   在成员名的后面是一个冒号和一个整数，这个整数指定该位所占用的位的数目
-   如果位段声明为int，编译器决定是有符号还是无符号
-   注重可移植性的程序应该避免使用位段
-   位段中的成员在内存中是从左向右分配还是相反，在不同机器上是不同的
-   位段声明的例子：
    -   例子
    ```c
    struct CHAR {
        unsigned ch     : 7;
        unsigned font   : 6;
        unsigned size   : 19;
    };
    
    struct CHAR ch1;
    ```
-   使用位段的理由：
    -   它能够把长度为奇数的数据包装在一起，节省存储空间
    -   可以很方便地访问一个整型值的部分内容

---

## 10.6 联合

-   联合的所有成员引用的是内存中相同位置
    -   例子：
    ```c
    union {
        float f;
        int i;
    }
    ```
-   如果f被使用，这个数就作为浮点值访问，如果i被使用，就作为整型值访问
-   如果联合的各个成员具有不同的长度，联合的长度就是它最长成员的长度

### 10.6.1 变体记录

-   变体记录：内存中某个特定的区域将不同的时刻存储不同类型的值，它们的每一个都是完整的结构
-   如果这些成员的长度相差悬殊，当存储短成员时，浪费的空间相当可观
-   为了节省空间，更好的办法是在联合中存储指向不同成员的指针而不是直接存储成员本身，因为所有指针的长度都是相同的

### 10.6.2 联合的初始化

-   联合变量可以被初始化，但这个初始化必须是联合第1个成员的类型，而且必须在一对花括号里
    -   例子：
    ```c
    union {
        int a;
        float b;
        char c[4];
    } x = { 5 };
    ```
-   如果给出的初始值时任何其他类型，它就会转换（如果可能的话）成一个整数并复制给x.a

---

## 10.7 总结

-   结构标签是一个名字，它与一个成员列表相关联
-   结构不能包含类型也是这个结构的成员，但它的成员可以是一个指向这个结构的指针，常常用于链式数据结构中
-   编译器为一个结构变量的成员分配内存时要满足它们的边界对齐要求
-   sizeof返回的值包含了结构中浪费的内存空间
-   位段是结构的一种，但它的成员长度以位为单位指定。位段声明在本质上是不可移植的

---

## 10.8 警告 

-   具有相同成员列表的结构声明产生不同类型的变量
-   使用typeof为一个自引用的结构定义名字时应该小心

--- 

## 10.9 编程提示的总结

-   把位段成员显示地声明为signed int或unsigned int类型

---

# 第11章 动态内存分配

-   数组被声明时，它所需要的内存在编译时就分配
-   也可以使用动态内存分配在运行时为它分配内存

---

## 11.1 为什么使用动态内存分配

---

## 11.2 malloc和free

-   malloc和free分别用于执行动态内存分配和释放，这些函数维护一个可用的内存池
-   malloc从内存池中提取一块合适的内存，返回这块内存起始位置的指针
-   如果这块内存需要初始化，要么手动进行初始化，要么使用calloc
-   free函数把malloc等函数分配的内存还给内存池
-   这些函数原型在stdlib.h中
-   `void *malloc ( size_t size );  //以字节为单位`
-   `void free( void *pointer );`
-   malloc实际分配的内存有**可能**比你请求的稍微多一点，由编译器定义
-   如果内存池是空的，或者它的可用内存无法满足请求，那么：
    -   malloc向系统请求要求得到更多内存，并在这块新内存上执行分配任务
    -   系统无法向malloc分配更多内存，malloc就返回一个NULL
-   free的参数
    -   NULL，函数不会产生任何效果
    -   malloc、calloc、realloc返回的值
-   malloc不知道内存的数据类型，返回void *类型的指针，可以转换为其他任何类型的指针
-   malloc所返回的内存的起始位置将始终能够满足对边界对齐要求最严格的类型的要求

---

## 11.3 calloc和realloc

```c
void *calloc( size_t num_element, size_t element_size);
void realloc( void *ptr, size_t new_size);
```
-   malloc和calloc区别：
    -   后者在返回指向内存的指针之前把它初始化为0   
    -   它们请求内存数量的方式不一样，calloc的参数包括所需元素的数量和每个元素的字节数
-   realloc用于修改一个原先已经分配的内存的大小，扩大或缩小
    -   如果原先的内存无法改变大小，realloc将分配另一块正确大小的内存，并把原先那块内存的内容复制到新的快上
    -   如果第一个参数是NULL，那么它的行为就和malloc一模一样

---

## 11.4 使用动态分配的内存

-   NULL定义于stdio.h，实际上是字面值常量0
-   malloc等函数分配出来的内存，不仅可以使用指针，也可以使用下标

---

## 1.5 常见的动态内存错误

-   常见错误
    -   对NULL指针进行解引用操作
    -   对分配的内存进行操作时越过边界
    -   释放并非动态分配的内存
    -   试图释放一块动态分配的内存的一部分
    -   一块动态内存被分配之后被继续使用
-   传递给free的指针必须是malloc、calloc或realloc返回的指针，让它释放一块并非动态分配的内存可能导致程序终止或在晚些时候终止
-   free释放一块内存的一部分是不允许的，动态分配的内存必须整体一块释放
-   realloc可以缩小动态分配的内存，有效地释放它尾部的部分内存

### 内存泄漏

-   分配内存但在使用完毕后不释放将引起内存泄漏（memory leak）

---

## 11.6 分配内存实例

-   free联合的任一成员都可以，因为free不会理会指向内容的类型

---

## 11.7 总结

-   malloc函数返回时内存并未以任何方式进行初始化
-   realloc增加内存块大小时可能采取的方式是把原来内存块上的所有数据复制到一个新的、更大的内存块上
-   内存泄漏是指内存被动态分配以后，当它不再使用时未被释放，内存泄漏会增加程序的体积，有可能导致程序或系统的崩溃

---

# 第12章 使用结构和指针

-   本章代码较多，涉及大多是链接插入操作的优化方法，复习本章更好的方法是看书

## 12.1 链表

-   链表就是一些包含数据的独立结构（通常称为节点）的集合
-   通过链或指针连接在一起
-   通常节点是动态分配的，但也有由节点数组构建的链表
-   通过指针来遍历链表

## 12.2 单链表

-   在单链表中，每个节点包含一个指向链表下一个节点的指针
-   链表最后一个节点的指针字段的值为NULL
-   为了记住链表的起始位置，可以使用一个根指针
-   根指针指向链表的第1个节点
-   链表中的节点可能分布于内存的各个地方
-   单链表无法从相反的方向进行遍历

--- 

## 12.3 双链表

-   在一个双链表中，每个节点都包含两个指针，一个指向前一个节点的指针和一个指向后一个节点的指针
-   链表第1个节点的bwd字段和最后一个节点的rwd字段都为NULL

---

## 12.4 总结

-   语句提炼是一种简化程序的技巧，其方法是消除程序中的冗余语句

---

## 12.5 警告的总结

-   从if语句中提炼语句可能会改变测试结果

## 12.6 编程提示的总结

-   不要仅仅根据代码的大小评估它的质量

---

# 第13章 高级指针话题

## 13.1 进一步探讨指向指针的指针 

---

## 13.2 高级声明

```c
//f是一个函数，这个函数的返回值是一个指向整型的指针
int *f();
//f是一个函数指针，它所指向的函数返回一个整型值
int (*f)();
//f是一个函数指针，它所指向的函数返回一个整型指针
int *(*f)();
//f是一个数组，数组的元素是整型指针
int *f[];
//f是一个函数，函数的返回值是一个整型数组，但是这个是非法的，因为函数只能返回标量，不能返回数组
int f()[];
//f是一个数组，数组的元素时返回值为整型的函数，但这个是非法的，因为数组元素必须具有相同的长度，但不同的函数显然可能具有不同的长度
int f[]();
//f是个数组，数组元素是函数指针，指针所指向的类型是返回值为整型的函数，其中int ()为指针指向的类型
int (*f[])();
//f是个数组，数组元素是函数指针，指针所指向的类型是返回值为整型指针的函数，其中int * ()为指针指向的类型
int *(*f[])();
```

---

## 13.3 函数指针

-   函数指针的用途：转换表和作为参数传递给另一个函数

```c
int f( int );
//初始化，在函数指针的初始化之前具有f的原型是很重要的，否则编译器无法检查f的类型是否与pf所指向的类型一致
int (*pf)( int ) = &f;  
```

-   初始化表达式中&操作符是可选的，因为函数名被使用时总是由编译器把它转换为函数指针
-   三种方式调用函数

```c
int ans;
ans = f( 25 );
//把指针函数转焕为一个函数名，这个转焕并不是真正需要的，因为编译器在执行函数调用操作符之前会把它转换为函数指针
ans = (*pf)( 25 );
ans = pf( 25 );
```

### 13.3.1 回调函数

-   回调函数：把一个函数指针作为参数传递给其他函数，被传递的这个函数称为回调函数

### 13.3.2 转移表

-   转换表就是一个函数指针数组
-   转换表需要两步操作
    -   声明并初始化函数指针数组
    -   用下面这条语句替换前面整条switch语句`result = oper_func[ oper ]( op1, op2 );`

---

## 13.4 命令行参数

### 13.4.1 传递命令行参数

-   C程序的main函数具有两个参数：
    -   `argc`：表示命令行参数的数目
    -   `agrv`：指向一组参数
    -   `int main( int argc, char **argv )`
-   在有些系统中，参数字符串是挨个存储的，这样当你把指向第1个参数的指针向后移动，越过第1个参数的尾部时，就达到了第2个参数的起始位置，即`++*argv`。但这个是由编译器决定的，不能依赖
-   为了徐州一个参数的起始位置，你应该使用数组中适合的指针，即`*++agr`，指向下一个数组元素，然后使用间接访问操作获得字符串指针

---

## 13.5 字符串常量

```c
//它的结果是个指针，指向字符串中第2个字符：y
"xyz"+1;
//它的结果一个字符，即x
*"xyz";
//以下结果为字符z
"xyz"[2]
//偏移量4超出了这个字符串的范围，是一个不可预测的字符
*("xyz"+4)
```

---

## 13.6 总结

-   字符串常量的值时一个常量指针，它指向字符串的第1个字符，和数组名一样，你既可以用指针表达式也可以用下标来使用字符串常量

---

# 第14章 预处理器

-   编译一个C程序的第1步称为预处理阶段
-   C预处理器在编译代码之前对其进行一些文本性质的操作
-   主要任务包括：
    -   删除注释
    -   插入被`#include`指令包含的文件的内容
    -   定义和替换由`#define`指令定义的符号
    -   确定代码的部分内容是否应该根据一些条件编译指令进行编译

---

## 14.1 预定义符号

-   预处理符号
    -   `_FILE_`:进行编译的源文件名
    -   `_LINE_`:文件当前行的符号
    -   `_DATE_`:文件被编译的日期
    -   `_TIME_`:文件被编译的时间
    -   `_STDC_`:如果编译遵循ANSI C，其值就为1，否则未定义

---
## 14.2 #define

-   `#define name stuff`
-   使用`#define`指定，可以把任何文本替换到程序中
-   如果定义的stuff很长，可以分行，每行的末尾使用`\`

### 14.2.1 宏

-   `#define`机制允许把参数替换到文本中，称为宏或者定义宏
-   `#define name(parameter-list) stuff` 左括号必须与name紧邻，不能有空格
-   一定要用宏替换产生的文本，来检查正确性
-   所有用于对数值表达式进行求值的宏定义都应该使用括号

### 14.2.2 `#define`替换

-   宏参数和`#define`定义可以包含其他`#define`定义的符号，但宏不可以出现递归
-   预处理器搜索`#define`定义的符号时，字符串常量的内容并不进行检查，如果想把宏参数插入到字符串常量中，可以
    -   方法1：利用邻近字符串自动连接的特性，把一个字符串分为几段，每一段实际上都是一个宏参数
    ```c
    #define PRINT(FORMAT,VALUE) printf( "The value is " FORMART "\n", VALUE)
    int x = 22;
    PRINT("%d", x+3 );
    
    //输出为：The value is 25
    ```
    -   方法2：`#argument`这种结构被预处理器翻译为`argument`
    ```c
     #define PRINT(FORMAT,VALUE) printf( "The value of " #VALUE "is" FORMART "\n", VALUE)
    int x = 22;
    PRINT("%d", x+3 );
    
    //输出为：The vaule of x+3 is 25
    ```

<br/>

-   `##`结构把位于两边的符号连接成一个符号
-   这种连接必须产生一个合法的标识符

```c
#define ADD_TO_SUM( sum_number, value ) \
        sum ## sum_number += value
...
//把25加到变量sum5中
ADD_TO_SUM( 5, 25 );
```

### 14.2.3 宏与函数

-   宏比函数的优势：
    -   规模和速度
    -   函数参数必须指定类型，而宏与类型无关
-   宏比函数的劣势：每次使用宏都要代码拷贝

### 14.2.4 带副作用的宏参数

-   当宏参数在宏定义中出现的次数超过一次时，如果这个参数具有副作用，那么使用这个宏就可能出现危险
-   副作用是在表达式求值时出现永久性效果

### 14.2.5 命名约定

-   一个常见的约定就是把宏名字全部大写
-   宏和函数的不同之处（参考P285 表14.2）：
    -   代码长度
    -   执行速度
    -   操作符优先级
    -   参数求值
    -   参数类型

### 14.2.6 #undef

-   移除一个宏定义`#undef name`

### 14.2.7 命令行定义

-   `int array[ARRAY_SIZE];`
-   可以使用两种方式来编译前定义
    -   `-Dname`
    -   `-Dname=stuff`
-   `cc -DARRAY_SIZE=100 prog.c`

---

## 14.3 条件编译

-   使用条件编译可以选择代码的一部分被正常编译还是完全忽略

```c
/*
常量表达式由预处理器进行求值，非零为真，为真则编译，否则忽略，常量表达式可以是字面值常量或#define定义的符号
*/
#if 常量表达式  
    语句
#endif

/*
#elif出现次数不限
#else语句只有前面所有的常量表达式的值都是假才会被编译
*/
#if 常量表达式
    语句
#elif 常量表达式
    其他语句
#else 
    其他语句
#endif
```

### 14.3.1 是否被定义

-   测试一个符号是否已经被定义

```c
if defined(symbol)
#ifdef symbol

#if !defined(symbol)
#ifndef symbol
```

-   每对定义的两条语句等价，但`#if`形式更强

### 14.3.2 嵌套指令

-   为每个`#endif`加上一个注释标签是很有帮助的

---

## 14.4 文件包含

-   `#include`指令替换执行的方式：预处理器删除这条指令，并包含文件的内容取而代之，一个头文件如果被包含到10个源文件中，它实际上被编译了10次
-   这样会涉及一些开销，但是这个开销只是在程序被编译时才存在，对运行时效率并无影响

### 14.4.1 函数库文件包含

-   两种不同类型的`#include`文件包含：函数库文件和本地文件
-   函数库头文件：`#include <filename>`，标准库文件以一个`.h`后缀结尾，运行于UNIX系统上的C编译器在/usr/include目录查找函数库头文件

### 14.4.2 本地文件包含

-   `include "filename"`
-   处理本地头文件的一种常见策略是在源文件所在的当前目录进行查找，未找到就按照查找函数库头文件一样在标准位置查找本地头文件
-   可以在所有的`#include`语句中使用双引号而不是尖括号，但对于函数库头文件，查找效率变低
-   也可以使用绝对路径`#include absolute_path`
-   如说使用绝对路径，那么正常的目录查找就被跳过

### 14.4.3 嵌套头文件包含

-   标准要求必须支持失少8层头文件嵌套，但它并没有限制嵌套深度的最大值
-   嵌套的不利之处
    -   它使得很难判断源文件之间的真正依赖关系
    -   一个头文件可能会被多次包含
-   解决多重包含，可以使用条件编译
    -   例如：
    ```c
    #ifndef _HEADERNAME_H
    #define _HEADERNAME_H 1   // <-----这里也可以直接 #define _HEADERNAME_H
    //  头文件
    #endif
    ```
    
---

## 14.5 其他指令

-   `#error`允许你生产错误信息`#error text of error message`
-   `#line number "string"`:该语句通知预处理器number是下一行输入的行号，`"string"`预处理器把它当做当前文件名。该语句会修改`_LINE_`和`_FILE_`
-   `#progma`用于支持因编译器而异的特性，它的语法也是因编译器而异，有些编译器使用`#progma`指令
    -      在编译过程中打开或关闭清单显示
    -      把汇编代码插入到C程序中
-   `#progma`是不可移植的
-   无效指令就是一个`#`符号开头，但后面不跟任何内容的一行
    -   例如：
    ```c
    #
    #include <stdio.h>
    #
    ```

---

## 14.6 总结

-   为了防止可能出现表达式中的于宏有关的错误，在宏完整定义的两边应该加上括号，在宏定义中每个参数的两边也要加上括号

---

## 14.7 警告的总结

-   不要在一个宏定义的末尾加上分号，使其成为一条完整的语句

---

# 第15章 输入\输出函数

