---
layout:     post
title:      "study19.《C和指针》知识点总结"
date:       2018-01-09 10:00:00
author:     "guanjunjian"
categories: 读书
tags:
    - study
    - summary
---

* content
{:toc}

>
> 《C和指针》 知识要点总结，持续更新
>




# 第3章 数据

-   作用域、链接属性 ---> 可视性（可以在什么地方使用）
-   存储类型 ---> 生命期（值将保持多久）

## 3.1 基本数据类型

-   4种基本数据类型：整型、浮点型、指针和聚合类型（数组、结构）

### 3.1.1 整型家族

-   1.整型家族包括字符、短整型、整型和长整型，又分为有符号和无符号
    -   a.字符：char、signed char、unsigned char（char和unsigend char长度不一样的）
    -   b.短整型：short int（至少16位）、unsigned short int
    -   c.整型：int、unsigned int
    -   d.长整型：long int（至少32位）、unsigend long int
-   2.长度比较：`长整型 >= 整型 >= 短整型`
-   3.头文件limits.h说明了各种不同的整型类型的特点：变量范围的限制
-   4.char类型变量在本质上是小整型值
-   5.缺省的char要么是sigend char，要么是unsigend char，这取决于编译器
-   6.char变量的值位于sigend char和unsigend char的交集中，这个程序才是可移植的
-   7.移植问题：最佳方案是将char限制在sigend char和unsigend char交集内，并且只有char显示声明为sigend或unsigend时才对它执行算术运算

#### 一、整型字面值

-   字面值是字面值常量的缩写，区分与常量
-   整型字面值属于哪种类型，取决于字面值是如何书写的，可以通过添加一个后缀来改变缺省的规则
-   在整数字面值后面添加L或l使这个整数解释为long整型值；U或u解释为unsigned整型值；可两个一起用

</br>

-   十进制整型字面值可能是`int、long或unsigend long`，缺省是它最短类型但能完整容纳这个值
-   八进制和十六进制整型字面值可能是`int、unsigend int、long或unsigend long`，，缺省是它最短类型但能完整容纳这个值
-   字符常量的类型总是`int`，不能添加unsigned或long后缀
    -   字符常量就是用一个单引号包围起来的单个字符（或字符转义序列或三个字母）例子在P31
    -   多字节字符常量的前面有一个L，那么它就是宽字符常量

#### 二、枚举类型

-   枚举类型就是指它的值为符号常量而不是字面值的类型
-   声明枚举类型:`enum Jar_Type { CUP, PINT, QUART }`
-   声明枚举类型的变量：`enum Jar_Type mikl_jug;`
-   匿名枚举类型声明
    - 例子：
    ```
    enum { CUP, PINT, QUART }
        mikl_jug;
    ```
-   枚举类型实际上是整型方式存储，CUP是0，PINK是1
-   同时也可以给符号名赋值，如果某个符号名赋值了，但下一个没赋值，那么这个没赋值的符号名就比上一个赋值了的符号名的值大1

### 3.1.2 浮点类型

-   非整数或数远远超出了计算机整数所能表达的范围，可以用浮点数的形式存储
-   浮点数通常以一个小数以及一个以某个假设数为基数的指数组成
-   包括float、double、long double，表示单精度、双精度、扩张精度
-   长度比较：`float >= double >= long double`
-   所有浮点至少能容纳从`10E-37`到`10E37`之间的任何值
-   float.h定义了浮点数家族的最大值、最小值
-   浮点字面值总是写成十进制的形式，必须有小数点或一个指数，或两个都有
-   浮点数字面值在缺省情况下都是double，除非跟了L或l（long double）和F或f（float）

### 3.1.3 指针

-   每个内存位置都由地址唯一确定并引用
-   指针只是地址的另一个名字
-   指针变量就是一个其值为另外一个（一些）内存地址的变量

#### 一、指针常量

-   指针常量与非指针常量在本质上是不同的
-   通过操作符获得一个变量的地址而不是直接把它的地址写成字面值常量的形式
-   指针常量表达式为字面值的形式几乎没有用处，所以C内部并没有特定第定义这个概念
-   例外：NULL指针，它可以用零值来表示

#### 二、字符串常量

-   C不存在字符串类型，但C提供了字符串常量
-   字符串的概念：以NUL字节结尾的0个或多个字符
-   字符串通常存储在字符数组中
-   字符串内部不能有NUL字节
-   字符串常量的书写方式是用一对双引号包围一串字符`"Hello"`
-   字符串常量（不像字符常量）可以是空的，但是依然有NUL字节终止
-   K&R C的字符串常量
    -   具有相同值的不同字符串常量在内存中是分开存储的
    -   编译器允许程序修改字符串常量
-   ANSI C的字符串常量
    -   对一个字符串常量进行修改，其效果未定义
    -   它允许编译器把一个字符串常量存储于一个地方
    -   修改字符串常量很危险
    -   许多ANSI编译器不允许修改字符串常量
    -   如果需要修改字符串，请把它存于数组中
-   字符串常量会生成一个“指向字符的常量指针”
-   字符串常量出现在表达式中，表达式所使用的值是字符存储的地址
-   把字符串常量赋给一个“指向字符的指针”
-   不能把字符串常量赋给一个字符数组，因为字符串常量的直接值是一个指针，不是这些值本身

---

## 3.2 基本声明

-   在声明整型变量时，如果声明中已经至少有了一个其他的说明符，关键字int可以省略`unsigend short int a;`和`unsigned short a;`是相等的
-   signed一般只用于char，因为其他类型在缺省情况下都是有符号数
-   相等的整型声明：
    -   表格：
    
    signed | unsigend
    ---|---
    `short`、`signed short`、`short int`、`signed short int` |  `unsigned short`、`unsigned short int`
    `int`、`signed int`、`sigend` | `unsigned int`、`unsigned`
    `long`、`signed long`、`long int`、`signed long int` | `unsigend long`、`unsigned long int`

### 3.2.1 初始化

### 3.2.2 声明简单数组

-   编译器并不检查程序对数组下标的引用是否在数组的合法范围之内

### 3.2.3 声明指针

-   声明指针应该`int *a;`而不应该`int* a;`
-   因为在`int* b,c,d;`会让人误以为b、c、d都是指针，其实这里只有b是指针，应该为`int *b,*c,*d;`

### 3.2.4 隐式声明

-   函数如果不显示地声明并返回值的类型，默认返回整型
-   旧风格声明函数的形式参数，如果忽略了参数的类型，默认为整型
-   编译器能得到足够信息，推断出一个语句是一个声明时，如果缺少类型名，会假设为整型
-   例子 P37

---

## 3.3 typedef

-   typedef机制允许你为各种数据类型定义新名字
    -   例子：
    ```c
    typedef char *ptr_to_char;   //ptr_to_char作为指向字符的指针类型的新名字
    ptr_to_char a;   //a是一个指向字符的指针
    ```

-   `#define`不法正确处理指针类型
    -   例子：
    ```c
    # define d_ptr_to_char  char *
    d_ptr_to_char a,b;  //这里只有a是字符指针，而b只是字符
    ```

-   复杂的类型名，如函数指针和指向数组的指针，使用typedef更合适

---

## 3.4 常量

-   const关键字声明常量，`int const a;`和`const int a;`都可以
-   常量如何拥有一个值
    -   声明时对它进行初始化，`int const a = 15;`
    -   形参在函数调用时会得到实参的值
-   关于指针（const往前结合）
    -   例子：
    ```c
    int *pi;  //普通的指向整型的指针
    int const *pci;  //指向整型常量的指针
    int * const cpi;  //指向整型的常量指针
    int const * const cpci;  //指向整型常量的常量指针
    ```
-   `#define`也可以创建名字常量`#define MAX 50`和`int const max = 50`一样

---

## 3.5 作用域

-   标识符的作用域就是程序中该标识符可以被使用的区域
-   4种作用域：文件作用域、函数作用域、代码块作用域、原型作用域
-   标识符声明的位置决定它的作用域

### 3.5.1 代码块作用域

-   花括号之间的所有语句称为一个代码块
-   任何在代码块开始位置声明的标识符都具有代码块作用域
-   代码块嵌套时，标识符同名，内层标识符隐藏外层标识符
-   `k&R C`函数形参作用域开始于形参的声明处，位于函数体外，局部变量可以隐藏形参
-   `ANSI C`形参作用域为函数最外层的那个作用域（整个函数体），局部变量不可能隐藏形参

### 3.5.2 文件作用域

-   代码块之外声明的标识符具有文件作用域
-   文件作用域：表示从标识符声明处起到源文件结尾都是可以访问的
-   文件中定义的函数名也具有文件作用域
-   `#include`包含到其他文件中的声明就好像直接写在那些文件中一样，它们的作用域不局限于头文件的文件文件尾

### 3.5.3 原型作用域

-   原型作用域只适用于在函数原型中声明的参数名
-   原型中的参数名不必与函数定义中的参数名匹配

### 3.5.4 函数作用域

-   函数作用域只适合于语句标签
-   语句标签用于goto语句
-   函数作用域可以简化为一条规则：一个函数中的所有语句标签必须唯一

---

## 3.6 链接属性

-   标识符的链接属性决定如何处理在不同文件中出现的标识符
-   标识符的作用域和它的链接属性有关
-   3种：external、internal、none
-   没有链接属性的标识符(none)：总是当作独立的个体
-   internal：同一个源文件内的所有声明都是指向同一个实体
-   external：无论声明多少次，位于几个源文件都是表示同一个实体
-   函数定义中的函数调用a，a的链接属性是external，它实际链接到其他文件所定义的函数，或某个函数库

<br/>

-   关键字`extern`和`static`用于声明中修改标识符的链接属性
-   具有external链接属性的标识符，加上static，变为internal
-   static只对缺省属性为external的声明才会有改变链接属性的效果
-   extern为一个标识符指定external链接属性
-   extern用于标识符的第1次声明时，它指定标识符具有external链接属性；用于标识符的第2次或以后的声明时，不会改变第一次声明所指定的链接属性
    -   例子：
    ```c
    static int i;  //声明1
    int func()
    {
        extern int i; //不修改由声明1所指定的变量i的链接属性
    }
    ```
    
---

## 3.7 存储类型

-   变量的存储类型是指存储变量值的内存类型：普通内存、运行时堆栈、硬件寄存器
-   存储类型决定变量何时创建、何时销毁和值保持多久
-   变量的缺省存储类型取决于它的声明位置
    -   代码块之外缺省：静态内存，称为静态（static）变量
    -   代码块内部缺省：堆栈中，称为自动（auto）变量
-   在代码块内部声明的变量，加上`static`，自动变为静态（修改变量的存储类型不代表修改变量的作用域）
-   形式参数不能声明为静态
-   `register`可以用于自动变量的声明，提示应该存储于硬件寄存器中，称为寄存器变量，但编译器不一定理睬
-   可以把函数的形式参数声明为寄存器变量
-   寄存器变量的创建和销毁时间和自动变量相同，但需要做一些额外工作：恢复先前存储的值

### 初始化

-   静态变量的初始化可以把初始化的值放在程序执行变量将会使用的位置，不显示地指定其初始值，静态变量将初始化为0
-   动态变量没有缺省值，如果不显示初始化，那么它们的值总是垃圾

---

## 3.8 static关键字

-   static的作用
    -   对于函数定义或代码外之外的变量声明：链接属性`external--->internal`，存储类型和作用域不受影响
    -   对于代码块内部变量声明：存储类型`自动变量--->静态变量`，链接属性和作用域不受影响

-   extern的作用
-   -   对于代码块内部变量:链接属性`none--->external`，存储类型`自动变量--->静态变量`，说明它所引用的是个全局变量而非局部变量（变量声明可能在别的源文件中）

---

## 3.9 作用域、存储类型示例

-   对于函数，存储类型并不是问题，因为代码总是存储在静态内存中

---

## 3.10 总结

-   如果一个变量声明与代码块内部，在它前面添加一个`extern`将使它引用的是全局变量而非局部变量（有可能是别的源文件中的）
-   具有external链接属性的实体总是具有静态存储类型
-   作用域、链接属性和存储类型总结
    -   表：
   
    变量类型 | 声明的位置 | 是否存储于堆栈 | 作用域 | 如果声明为static | 如果声明为extern
    ---|---|---|---|---|---|
    全局 | 所有代码块之外 | 否 | 从声明处到文件尾 | 不允许从其他源文件访问，变为internal | --- |
    局部 | 代码块起始处 | 是 | 整个代码块 | 变量不存储于堆栈中，它的值在程序整个执行期一直保持 | 引用的是全局变量而非局部变量
    形式参数 | 函数头部 | 是 | 整个函数 | 不允许 | --- |

---

## 3.12 编程提示的总结

-   除了实体的具体定义位置外，在它的其他声明位置都要使用`extern`关键字

---

# 第5章 操作符和表达式

## 5.1 操作符

### 5.1.1 算数操作符

-   1.`+ - * / %`
-   2.`%`只能用于整数类型

### 5.1.2 位移操作符


-   1.`<<`左移操作，移出界的丢弃
-   2.`>>`右移，左边移入新位时有两种方案
    -   a. 逻辑移位：左边移入的用0填充
    -   b. 算数移位：左边移入的由原先的符号位决定
-   3.位移操作符的两个操作数都必须是整形类型
-   4.无符号值都是逻辑位移，有符号值由编译器决定
-   5.`a << -5`这个位移的值是不可预测的

### 5.1.3 位操作符

-   1.AND、OR、XOR; `&、|、^`

### 5.1.4 赋值

-   1.赋值是表达式的一种，而不是某种类型的语句（没有赋值语句）
-   2.赋值是表达式，所以它就具有一个值，赋值表达式的值就是左操作数的新值，可以作为其他赋值操作符的右操作数，如`a = x = y + 3`,即`a = ( x = y + 3 )`
-   3.`a = x = y + 3`认为a和x被赋予相同的值的说法是错误的，因为可能变量类型不同，比如x是字符型变量，那么y+3的值就会被截去一段，所以以下代码是错误的（具体参照P70）
    - a.   
        ```
        char ch;
        ...
        while( ( ch = getchar() ) != EOF )...
        ```
-   4.复合赋值符：`+=、<<=、&=`等等，`a += expression`等于`a += a + ( expression )`

### 5.1.5 单目操作符

`!、++、-、&、sizeof、~、--、+、*、(类型)`

-   1.`~`:按位取反
-   2.`-`：负值
-   3.`+`:正值，与`-`相对
-   4.`&`:取地址
-   5.`*`:间接访问操作符，与指针一起用
-   6.`sizeof`:操作数的类型长度，字节为单位;`sizeof (int)`、`sizeof x`;当操作数为数组名时，返回数组的长度，以字节为单位;判断表达式的长度不需要对表达式求值，所以`sizeof( a = b + 1 )`并没有向a赋值
-   7.`(类型)`：强制类型转换
-   8.`++和--`:操作数必须是个“左值”；前缀形式：操作数的值被增加，表达式是操作数增加后的值；后缀形式：操作数的值被增加，表达式是增加前的值；增值操作符都是复制一份变量值的拷贝，用于表达式的值正式这份拷贝，前缀后缀只是复制的时间不一样，因此`++a = 10`是错误的，因为不能向一个拷贝值进行赋值（P73）

### 5.1.6 关系操作符

`>   >=   <   <=   !=   ==`

-   这些操作符产生的结果都是整型值1或0，不是布尔值

### 5.1.7 逻辑操作符

`&&   ||`

-   短路求值

### 5.1.8 条件操作符

`expression1 ? expression2 : expression3`

### 5.1.9 逗号操作符

`,`

-   逗号操作符将多个表达式分隔开来，这些表达式自左向右逐个进行求值
-   `if( b + 1, c / 2, d > 0)`这里看的是`d > 0`

### 5.1.10 下标引用、函数调用和结构函数

-   C的下标值总是从0开始，并且不会对下标值进行有效性验证
-   除了优先级不同外，下标引用操作和间接访问表达式是等价的
    -   `array[ 下标 ]`和`*( array + ( 下标 ) )`
-   `.`和`->`操作符用于访问一个结构的成员，当你拥有一个指向结构体的指针而不是结构体本身时，使用`->`访问它的成员

---

## 5.2 布尔值

-   C不具备显示的布尔类型，使用整数代替
-   零是假，任何非零值为真
-   注意这类写法，flag为1以外的其他非零值，这个if语句也是不执行的：
    - a.
    ```
    #define FALSE 0
    #define TRUE 1
    if( flag == TRUE)
    ```
---

## 5.3 左值和右值

-   左值就是那些能够出现在复制符号左边的东西，右值同理
-   “表达式不能作为左值”这句话是错的：`a[ b + 10 ] = 0`中的左值就是表达式，这些操作符包括间接访问操作符和下标引用

---

## 5.4 表达式求值

### 5.4.1 隐式类型转换

-   整型升级：字符型加法运算时，会提升为普通整型

### 5.4.2 算术转换

-   寻常算术转化（P80）

### 5.4.3 操作符的属性

-   复杂表达式的求值顺序3个决定因素：操作符的优先顺序、操作符的结合性（`L-R`、`R-L`）、操作符是否控制执行的顺序（`&&`、`||`）
-   操作符优先级表 p81

### 5.4.4 优先级和求值的顺序

-   `c + --c`根据编译器的不同会产生不同的结果

---

## 5.5 总结

-   `&&`、`||`和`?:`对求值过程施加控制
-   逗号操作符，整个表达式的值是最右那个子表达式的值
-   各个不同类型之间的值不能直接进行运算，除非其中一个的操作数转换为另一个操作数的类型（寻常算术转换）
-   表达式的结果如果依赖于求值的顺序，那么它在本质上就是不可移植的，应该避免使用（P86）
-   不要混用整型和布尔型值

---

# 第6章 指针

## 6.1 内存和地址

-   字节：8个位
-   字：许多机器以字为单位存储整数，每个字一般由2个或4个字节组成
-   尽管一个字包含了4个字节，它仍然有一个地址，或是最左边那个字节或是最右边那个字节
-   边界对齐
-   内存中的每个位置都由一个独一无二的地址标识；内存中的每个位置都包含一个值

---

## 6.2 值和类型

-   不能简单地通过检查一个值的位来判断它的类型，为了判断值的类型，必须观察程序中这个值的使用方式

---

## 6.3 指针变量的内容

-   一个变量的值就是分配给这个变量的内存位置所存储的数值，要区分与指针的内容

---

## 6.4 间接访问操作符

-   通过一个指针访问它所指向的地址的过程称为间接访问或解引指针，使用`*`

---

## 6.5 未初始化和非法的指针

    ```
    int *a;
    ...
    *a =12;
    ```
    
-   是错误的，因为没有对a进行初始化

---

## 6.6 NULL指针

-   要使一个指针变为NULL，你可以给它赋一个零值
-   为了测试一个指针变量是否为NULL，你可以将它与零值进行比较
-   对一个NULL指针进行解引用操作是非法的

---

## 6.7 指针、间接访问和左值

-   间接访问操作符所需要的操作数是一个右值，但这个操作符所产生的结果是个左值

---

## 6.8 指针、间接访问和变量

-   `*&a = 25`和`a = 25`从结果上来说是一样的

##  6.9 指针常量

-   `*100 = 25`是非法的
-   `*(int *)100 = 25`是合法的
-   指针常量通常用来根据已经设备的设备地址来访问设备

---

## 6.10 指针的指针

-   声明：`int **c`
-   声明为register的指针变量，不可以再使用&取址（P99）

---

## 6.11 指针表达式

-   cp作为字符指针，`++cp`是不能成为左值的，这个运行结果的返回值是原cp指向地址的下1个地址
-   cp作为字符指针，`cp--`是不能成为左值的，这个运行结果的返回值是原cp指向的地址
-   对于`*++cp`、`*cp++`、`++*cp`参考P103
-   由于后缀`++`的优先级高于`*`,所以`*cp++`分为三步：
    -   1. ++操作产生cp的一份拷贝
    -   2. 然后++操作符增加cp的值
    -   3. 最后，在cp的拷贝上执行间接访问操作
-   `++*++cp`、`++*cp++`参考P104

---

## 6.12 实例

---

## 6.13 指针运算

-   指针加上一个整数的结果是另一个指针，如果p是个指向float的指针，那么p+1就指向下一个float

### 6.13.1 算术运算

-   C的指针算术运算只限于两种形式：1.`指针 +/- 整数`；2.`指针 - 指针`
-   `指针 +/- 整数`
    -   标准定义这种形式只能用于指向数组中某个元素的指针
    -   这类表达式的结果类型也是指针
-   `指针 - 指针`
    -   只有当两个指针都指向同一个数组中的元素时，才允许一个指针减去另一个指针
    -   结果类型是ptrdiff_t，一种有符号整数类型
    -   减法运算的值时两个指针在内存中的距离，以数组元素的长度为单位，不是以字节为单位
    -   ptrdiff_t = 实际内存差 / 数组类型长度
    -   存在`p1 - p2 = 负数`的情况，只要两个指针都指向同一个数组的元素

### 6.13.2 关系运算

-   `<      <=      >       >=`
-   前提是指向同一个数组中的元素
-   比较表达式将告诉你哪个指针指向数组中更前或更后的元素

---

## 6.14 总结

-   无法通过值的位模式来判断它的类型，类型是通过值的使用方式隐形确定的
-   声明一个指针变量并不会自动分配任何内存，在指针执行间接访问前，指针必须进行初始化，或使它指向现有的内存，或给它分配动态内存
-   NULL指针执行间接访问操作的后果因编译器而异，常见后果为：返回内存位置零的值或终止程序
-   指针常量：通过把整型值强行转换为指针类型来创建它
-   指针加法运算，如果指针指向数组最后一个元素后面的那个内存位置仍是合法的
-   

---

## 6.15 警告

-   错误地对一个未初始化的指针变量进行解引用
-   错误地对一个NULL指针进行解引用
-   向函数错误地传递NULL指针
-   未检测到指针表达式的错误，从而导致不可预料的结果
-   对一个指针进行减法运算，使它非法地指向了数组第1个元素的前面的内存位置
---

# 第7章 函数

## 7.1 函数定义

-   函数的定义就是函数体的实现
-   函数声明出现在函数被调用的地方，函数声明向编译器提供函数的相关信息，用于确保函数被正确地调用
-   存根(stub)：应该就是一个空函数。编写这类存根，或者说为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性，以便于你编译和测试程序的其他部分
    ```
    function_name()
    {
    }
    ```
-   过程类型的函数：没有返回值
-   真函数：从表达式内部调用的，必须返回一个值，用于表达式的求值

---

## 7.2 函数声明

### 7.2.1 原型

-   第2种向编译器提供函数信息的方法是使用函数原型（第1种应该是函数定义）
-   使用原型最方便的方法是把原型置于一个单独的文件，使用`#include`指令包含该文件
-   `int func( int i );`中`;`区分了函数原型和函数定义的起始部分
-   原型中的参数名字并不是必需的
-   函数原型具有文件作用域，所以原型的一份拷贝可以作用于整个源文件
-   函数原型必须与函数定义匹配
-   `int *func()`不能表示一个没有参数的函数的原型，因为旧式风格的有参函数是可以这样声明的，一个没有参数的函数原型应该写成`int *func(void)`

### 7.2.2 函数的缺省认定

-   当程序调用一个无法见到原型的函数时，编译器认为该函数返回一个整型值
-   所有的函数都应该具有原型，尤其是那些返回值不是整型的函数
-   如果编译器认定函数返回一个整型值，它将产生整型数指令操作这个值（如果返回的不是整型值，那将会出错，例子参考P121）

---

## 7.3 函数的参数

-   1.所有参数均以“传值调用”方式进行传递，这意味着函数将获得参数值的一份拷贝
-   2.数组并不会得到一份拷贝，而是得到数组首地址的一份拷贝，这个行为被称为“传值调用”，因为数组名的值实际上是一个指针，传递给函数的就是这个指针的一份拷贝
-   3.记住两个规则：
    -   a.传递给函数的标量参数是传值调用的
    -   b.传递给函数的数组参数在行为上就像它们是通过传址调用的那样
-   4.在函数参数声明中，声明数组参数时不指定它的长度是合法的，因为函数并不为数组元素分配内存

---

## 7.4 ADT和黑盒

-   C可以用于设计和实现抽象数据类型（ADT，abstract data type），也被称为黑盒设计
-   抽象数据类型的基本想法：模块具有功能说明和接口说明
-   限制对模块的访问是通过`static`关键字的合理使用实现的，它可以限制那些并非接口的函数和数据的访问

---

## 7.5 递归

-   C通过运行时堆栈支持递归函数的实现，递归函数就是直接或间接调用自身的函数。

### 7.5.1 追踪递归函数

-   追踪一个递归函数执行过程的关键是理解函数中所声明的变量是如何存储的，因此可以通过画堆栈图来理解（参考P128的例子）

### 7.5.2 递归与迭代

-   1.递归函数调用将涉及一些运行时开销
    -   a.参数必须压到堆栈中
    -   b.为局部变量分配内存空间
    -   c.寄存器的值必须保存
-   2.因此递归函数的开销是十分大的
-   3.尾部递归：当一个函数在递归调用返回之后不再执行任何任务，这样的递归函数叫尾部递归
-   4.尾部递归可以很方便地转换成一个简单循环，完成相同任务，但开销更小
-   5.迭代实现往往比递归实现效率更高，但代码可读性稍差
-   6.如果一个问题相当复杂，难以用迭代形式实现时，此时递归实现的简便性可以补偿它所带来的运行时开销

---

## 7.6 可变参数列表

-   1.宏是由预处理器实现的
-   2.可变参数列表是通过宏来实现的，这些宏定义于stdarg.h头文件，它是标准库的一部分
-   3.分别有一个类型`va_list`和三个宏`va_start`、`va_arg`和`va_end`
-   4.参数列表中的省略号提示此处可能传递数量和类型未确定的参数，编写函数原型时，也要使用同样的记法
-   5.可变参数必须从头到尾按顺序逐个访问，半途终止是可以的，但不能一开始就访问参数列表中的中间的参数
-   6.由于可变参数部分没有原型，可变参数传递给函数的值都将执行缺省参数类型的提升（//TODO 不明白什么意思）
-   7.这些宏存在两个基本限制，是由“一个值的类型无法简单地通过检查它的位模式来判断”导致的
    -   a.这些宏无法判断实际存在的参数的数量
    -   b.这些宏无法判断每个参数的类型
-   8.要回答`7.`中的两个问题，就必须使用命名参数
        

```c
#include <stdarg.h>

float
average ( int n_values, ...)
{
    //用于访问参数列表的未确定部分
    va_list var_agr;
    int count;
    float sum = 0;
    
    //使用va_start来初始化，第1个参数是va_list变量的名字，第2个参数是省略号前最后一个有名字的参数，初始化过程把var_arg变量指向可变参数部分的第1个参数
    va_start( var_agr, n_values );
    
    for( count =0; count < n_values; count +=1 ){
        //访问参数，第1个变量va_list变量，第2个变量，参数列表中下一个参数的类型。va_arg返回这个参数的值，并使var_arg指向下一个可变参数
        sum += va_arg( var_arg, int );
    }
    //访问完毕最后一个可变参数之后，需要调用va_end
    va_end( var_arg );
    
    return sum / n_values;
}
```

---

## 7.7 总结

-   1.参数列表有两种可以接受的形式：K&R C风格和新风格
-   2.函数声明也有两种可以接受的形式：
    -   a.K&C C每个没有参数列表，只声明了返回值的类型
    -   b.新风格又称为函数原型，包含了参数列表的声明
-   3.对于那些没有原型的函数，传递给函数的实参将进行缺省参数提升
    -   a.char和short转换为int
    -   b.float转换为double