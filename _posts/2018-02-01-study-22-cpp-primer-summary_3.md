---
layout:     post
title:      "「二十二」《C++Primber》笔记 第Ⅲ部分 "
date:       2018-02-02 20:00:00
author:     "guanjunjian"
categories: 阅读
tags:
    - study
    - summary
---

* content
{:toc}

>
> 《C++Primer》笔记 第Ⅲ部分 类设计者的工具
> 
> 包括第13至16章
> 
> [第13章 拷贝控制] [第14章 重载运算符与类型转换] [第15章 面向对象程序设计] [第16章 模板与泛型编程] 
> 
> 第五版 
>

# 第13章 拷贝控制

-   参考[《C++11学习笔记 (12)》](https://wenku.baidu.com/view/03218cd7960590c69ec37673.html)
-   当定义一个类时，我们显示地或隐式地指定在此类的对象拷贝、移动、赋值和销毁时做什么  
-   五种特殊的成员函数来控制这些操作，这些操作称为拷贝控制操作
    -   拷贝构造函数：定义了当用同类型的另一个对象初始化本对象时做什么
    -   拷贝赋值运算符：将一个对象赋予同类型的另一个对象时做什么
    -   移动构造函数：定义了当用同类型的另一个对象初始化本对象时做什么
    -   移动赋值运算符：将一个对象赋予同类型的另一个对象时做什么
    -   析构函数：定义了当此类型对象销毁时做什么
-   不显示定义这些操作，编译器也会为我们定义，但编译器定义的版本的行为可能并非我们所想

---




## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

-   如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值（即调用时最少只需要传入一个参数），则此构造函数为拷贝构造函数
-   第一个参数必须是一个引用类型，虽然可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用
-   拷贝构造函数在很多情况下都会被隐式使用，因此，拷贝构造函数通常不应该是explicit的

```c
class Foo{
public:
    Foo(); //默认构造函数
    Foo(const Foo&); //拷贝构造函数
}
```

#### 合成拷贝构造函数

-   即使我们定义了其他构造函数，但是没有定义拷贝构造函数，那么编译器也会为我们合成一个默认拷贝构造函数
-   合成拷贝构造函数的作用有两种（它们是或关系）：
    -   用来组织我们拷贝该类的对象
    -   将其参数的成员逐个拷贝到正在创建的对象中，依次将每个非static成员拷贝到正在创建的对象中
-   合成拷贝构造函数如何拷贝成员，由成员的类型决定：
    -   类类型：使用其拷贝构造函数拷贝
    -   内置类型（除了数组）：直接拷贝
    -   内置数组：逐元素地拷贝

#### 拷贝初始化

-   区分直接初始化与拷贝初始化：
    -   直接初始化实际上是要求编译器使用普通的函数匹配来选择最匹配的构造函数创建一个对
    -   拷贝初始化则是要求编译器将右侧运算对象拷贝到正在创建的对象中（调用拷贝构造函数？？不应该是调用拷贝赋值运算符吗？），如果需要的化还要进行类型转换

```c
string dots(10,'.');     //直接初始化
string s(dots);           //直接初始化
string s2=dots;        //拷贝初始化
string null_book="9-999-99999-9";    //拷贝初始化
string nines=string(100,'9');        //拷贝初始化
```

-   拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生
    -   将一个对象作为实参传递给一个非引用类型的形参时  
    -   从一个函数返回一个非引用类型的对象时
    -   用花括号初始化一个数组中的元素或一个聚合类中的成员时
    -   某些类类型还会对它所分配的对象使用拷贝初始化，如初始化标准库容器或是调用其insert或push成员，进行的是拷贝初始化；调用emplace进行的直接初始化

#### 参数和返回值

-   为什么拷贝构造函数自己的参数必须是引用类型：
    -   因为拷贝构造函数被用来初始化非引用类类型参数，如果其参数不是引用类型，则调用永远不会成功

### 13.1.2 拷贝赋值运算符

-   类可以控制其对象如何赋值
-   如果类未定义自己的拷贝赋值运算符，那么编译器也会合成一个默认的拷贝赋值运算符

#### 重载赋值运算

-   重载运算符将在14章详细介绍，这里先是简单的说一下
-   重载运算符本质上是函数，其函数名由operator关键字后接表示要定义的运算符的符号组成，对于赋值运算符来说就是名为`operator=`的函数
-   重载运算符的参数表示运算符的运算对象，某些运算符，包括赋值运算符，必须定义为成员函数
-   如果一个运算符时一个成员函数
    -   其左侧运算对象就绑定到隐式的this参数
    -   对于一个二元运算符，例如赋值运算，其右侧运算对象作为显示参数传递

```c
class Foo{
public:
Foo& operator=(const Foo&);    //赋值运算符
}
```

-   赋值运算符通常返回一个指向其左侧运算对象的引用，标准库通常要求保存在容器中的类型要具有赋值运算符，且返回值是其左侧对象的引用

#### 合成拷贝赋值运算符

-   合成拷贝赋值运算符的作用有两种（它们是或关系）：
    -   用来禁止该类对象的赋值
    -   将右侧运算对象的每个非static成员赋予运算符左侧运算对象的对应成员
-   合成拷贝赋值运算符如何赋值成员，由成员的类型决定：
    -   类类型：使用其拷贝赋值运算符
    -   内置类型（除了数组）：直接赋值
    -   内置数组：逐元素地赋值    

```c
//等价于合成拷贝运算符
Sales_data& Sales_data::operator=(const Sales_data &rhs)
{
	bookNo = rhs.bookNo;          // calls the string::operator=
	units_sold = rhs.units_sold;  // uses the built-in int assignment
	revenue = rhs.revenue;        // uses the built-in double assignment
	return *this;                 // return a reference to this object
}
```

### 13.1.3 析构函数

-   析构函数释放函数对象使用的资源，并且销毁对象的非static数据成员
-   析构函数是类的成员函数，其没有返回值，也不接受任何参数，所以其不可以被重载，对一个给定类，只会有一个唯一的析构函数
-   函数名由波浪号接类名构成

```c
class Foo{
public:
    ~Foo(); //析构函数
}
```

#### 析构函数完成什么工作

-   析构函数由一个函数体和析构部分组成
    -   首先执行函数体
    -   然后执行析构部分（析构部分是隐式的），销毁成员，成员销毁按初始化顺序的逆序销毁
-   成员销毁时发生什么完全依赖于成员的类型
    -   类类型：执行自己的析构函数（智能指针是类类型，具有析构函数，在析构阶段会被自动销毁）
    -   内置类型：什么也不做（注意：隐式销毁内置指针类型的成员不会delete它所指向的对象）

#### 什么时候调用析构函数

-   无论何时一个对象被销毁，就会自动调用其析构函数：
    -   变量在离开其作用域时被销毁  
    -   当一个对象呗销毁，其成员被销毁
    -   容器（标准容器或数组）被销毁时，其元素被销毁
    -   动态分配的对象，当对指向它的指针应用delete时被销毁
    -   对于临时对象，创建它的完整表达式结束时被销毁
-   析构函数是自动运行的
-   当指向一个对象的引用或指针离开作用域时，被指向的对象的析构函数不会执行

#### 合成析构函数

-   当类未定义自己的析构函数时，编辑器会自己定义一个合成析构函数
    -   对于某些类，合成析构函数被用来阻止该类型的对象被销毁
    -   如果不是以上情况，合成析构函数的函数体就为空。在（空）析构函数执行完毕后，成员会被自动销毁（标准库的类会自动释放，内置类型变量什么也不做，指针指向的对象不会被销毁）
-   析构函数自身并不直接销毁成员。成员实在析构函数体之后隐含的析构阶段中被销毁的
-   析构函数体是作为成语销毁之外的另一部分而进行的

### 13.1.4 三/五法则

-   如果一个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
-   如果一个雷需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符，反之亦然
-   无论是需要拷贝构造函数还是拷贝赋值运算符都不必然意味着也需要析构函数

### 13.1.5 使用=default

-   将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本
-   当我们在类内使用=default时，合成的函数将隐式的声明为内联函数，如果我们不需要内联应该只在类外定义时使用=default
-   只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）

```c
~Sales_data() =default; //显示的要求编译器生成合成的析构函数
```

### 13.1.6 阻止拷贝

-   有时候类必须采取某种机制阻止拷贝和赋值
    -   iostream类就阻止了拷贝，以避免多个对象写入或读取相同IO缓冲

#### 定义删除的函数

-   通过将拷贝构造函数和拷贝运算符定义成删除的函数来阻止拷贝
-   虽然声明了它们，但不能以任何方式使用它们
-   方式是在参数列表后加上=default来指出我们希望将它定义为删除的
-   =delete通知编译器（以及代码的读者），我们不希望定义这些成员
-   与=default不同之处
    -   =delete必须是在函数第一次声明出现的时候
    -   可以对任何函数指定delete（除了析构函数）
-   当我们希望引导函数匹配过程时，删除函数有时也是很有用的

```c
struct NoCopy{
    ...
    NoCopy(const NoCapy& ) = delete; //阻止拷贝构造函数
    ...
}
```

#### 析构函数不能是删除的成员

-   我们不能定义析构函数时删除函数
-   如果将析构函数定义成删除函数（或是类的某个成员的类型是删除析构函数），我们不能定义该类的变量或临时对象
-   可以定义动态分配这种类型的对象。但是，不能释放这些对象

```c
struct NoDtor{
    NoDtor() = default;
    ~NoDtor() = delete;
}

NoDtor nd; //错误，NoDtor的析构函数是删除的 
NoDtor *p = new NoDtor(); //正确
delete p; //错误，NoDtor的析构函数是删除的
```

#### 合成的拷贝控制成员可能是删除的

-   如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
-   一个成员由删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的
-   对于具有引用成员或const成员的类，编译器不会为其合成默认构造函数，也不能使用合成的拷贝赋值运算符
    -   原因：试图赋值所有成员，而将一个新值赋予一个const对象是不可能的

#### private拷贝控制

-   在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝的
-   为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但并不定义它们
-   声明但不定义一个成员函数是合法的，对此只有一个例外（将在15.2.1介绍）
    -   试图访问一个未定义的成员将导致一个链接时错误
-   通过声明（但不定义）private的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图
    -   试图拷贝对象的用户代码将在编译阶段被标记为错误
    -   成员函数或友元函数中的拷贝操作将导致链接时错误

---

## 13.2 拷贝控制和资源管理

-   拷贝控制和资源管理有两种方式
    -   令类的行为像一个值
    -   令类的行为像一个指针
-   但也有既不像值也不像指针，例如IO类和unique_ptr不允许拷贝和赋值
-   如何拷贝指针成员决定了类是具有类值行为还是类指针行为

### 13.2.1 行为像值的类

-   类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝
-   当你编写赋值运算符时，需要记住：如果将一个对象赋予它自身，赋值运算必须能正确工作（最主要的是赋值和销毁的顺序）。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象

### 13.2.2 定义行为像指针的类

-   类似指针的类，拷贝指针成员本身而不是它指向的内容
-   仍然需要自己的析构函数来释放指针成员指向的内存，但不能单方面地释放，只有当最后一个指向该内存的类的成员销毁时，才可以释放。最好的方法是使用shared_ptr

---

## 13.3 交换操作

-   管理资源的类通常还定义一个名为swap的函数
-   如果一个类定义了自己的swap，那么算法将使用类自定义版本；否则算法会使用标准库中的swap
-   内置类型是没有特定版本的swap的，所以会调用标准库的std::swap；如果一个类的成员有自己类型特定的swap函数，调用std::swap就是错误的了
-   如果存在类型特定的swap版本，其匹配程序优于std中定义的版本，不存在时才会调用std::swap

#### 在赋值运算符中使用swap

-   定义swap的类通常用swap来定义它们的赋值运算符，这些运算符使用了一种名为拷贝并交换的技术

```c
//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数将右侧运算对象拷贝的rhs
HasPtr& HasPtr::operator = (HasPtr rhs) {
    //交换左侧运算对象和局部变量rhs的内容
    swap(*this, rhs); //rhs现在只想本对象曾经使用的内存
    return  *this;  //局部变量rhs离开函数体，它被销毁，从而delete了rhs中的指针
} 
```

---

## 13.6 对象移动

-   存在对象移动的原因：
    -   在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素
    -   IO类或unique_ptr这样的类，都包含了不能被共享的资源（如指针或IO缓冲），因此这些类的对象不能拷贝只能移动

### 13.6.1 右值引用

-   右值引用：必须绑定到右值的引用，但只能绑定到一个将要销毁的对象，通过&&来获得右值的引用
-   我们可以自由地将一个右值引用的资源“移动”到另一个对象中
-   一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值
-   右值表达式可以绑定到：
    -   要求转换的表达式
    -   字面常量（绑定在字面值时，它会用字面值构造一个临时变量，右值引用再绑定到这个临时变量上）
    -   返回右值的表达式

```c
int i = 42;
int &r = i; // 正确
int &&rr = i ; // 错误，不能将一个右值引用绑定到一个左值上
int &r2 = i * 42 ; // 错误，i*42是右值
const int &r3 = i*42; // 正确，我们可以将一个 const 的引用绑定到一个右值上
int &&rr2 = i * 42 // 正确

```

-   对比内置类型与自定义类类型的左值引用与右值引用

```c
Foo f(5);
Foo &&rref = f; //错误，右值引用不能绑定到变量上
Foo &&rref2 = Foo(5); //正确，Foo(5)是一个临时量，是一个右值
Foo(5) = Foo(8); //正确，修改了临时量的值
rref2 = Foo(8); //正确，修改了临时量的值

int i = 5;
int &&rref = i; //错误，右值引用不能绑定到变量上
int &&rref2 = 5; //正确，5是个整型字面值常量，会使用5来创建一个临时量，然后rref2绑定到这个临时变量上
5 = 8; //错误，不能对字面值赋值
rref2 = 8; //正确，相当于修改了rref2绑定在的那个临时量的值
```

-   右值引用或const的左值引用都可以绑定到右值上

-   返回左值的例子：
    -   返回左值引用的函数   
    -   赋值运算符
    -   下标运算符
    -   解引用运算符
    -   前置递增/递减运算符
-   返回右值的例子
    -   返回非引用类型的函数
    -   算术运算符
    -   关系运算符
    -   位运算符
    -   后置递增/递减运算符   

#### 左值持久，右值短暂

-   左值有持久的状态
-   右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，都具有短暂性
-   由于右值引用只能绑定到临时对象，我们知道
    -   所引用的对象将要被销毁
    -   该对象没有其他用户
-   使用右值引用的代码可以自由地接管所引用的对象的资源

-   变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变是右值引用类型也不行

```c
int &&rr1 = 42; //正确，字面值常量是右值
int &&rr2 = rr1; //错误，表达式rr1是左值
```

#### 标准库move函数

-   可以显式的将一个左值转换为对应的右值引用类型
-   调用move，在头文件utility中
-   move告诉编译器，我们有一个左值，但我们希望像右值一样处理它
-   调用move就意味着承诺：除了对rr1赋值或销毁它外，将不再使用它，即对于移后源对象，可以销毁，可以赋值，但不能再使用它的值

```c
int &&rr3 = std::move(rr1); //正确
```

### 13.6.2 移动构造函数和移动赋值运算符

-   移动构造函数和移动赋值运算符从给定的对象“窃取”资源而不是拷贝资源
-   移动构造函数的第一个参数是该类类型的以个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参
-   一旦资源完成移动，源对象必须不再指向被移动的资源，这些资源的所有权已经归属新创建的对象

```c
//noexcept表示：移动操作不抛出任何异常
//成员初始化其接管s中的资源
StrVec:StrVec(StrVec &&s) noexcept :: elements(s.elements) ,first_free(s.first_free) , cap(s.cap)
{
    //令s中的指针成员为空，对其运行析构函数后，就不会释放之前它指向的资源
    s.elements = s.first_free = s.cap =nullptr;
}
```

#### 移动操作、标准库容器和异常

-   由于移动资源，通常是不分配任何资源的，因此通常不会抛出任何异常
-   当编写一个不抛出异常的移动操作时，我们应该告诉标准库，来阻止标准库为了处理抛出异常的可能性而做的一些额外的工作
-   一种通知方法就是使用noexcept，必须在声明和定义（如果定义在类外）都指定noexcept
-   不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
-   如果希望在vector重新分配内存这类情况下对自己定义类型的对象进行移动而不是拷贝，那么就显示的告诉标准库我们的移动构造函数可以安全的使用。通过标记为noexcept来做到

#### 移动赋值运算符

-   移动赋值运算符执行与析构函数和移动构造函数相同的工作（析构函数+移动构造函数）

#### 移后源对象必须可解析

-   编写一个移动操作时，必须确保移后源对象进入一个可解析的状态（如将指针成员设为nullptr）
-   在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其值进行任何假设

#### 合成的移动操作

-   编译器会合成移动构造函数和移动赋值运算符
-   如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符
-   如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来替代
-   只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编辑器才会为他们合成移动构造函数或移动赋值运算符
-   编译器可以移动内置类型成员，还能移动定义了对应移动操作的类

```c
struct X hasX{
    X mem; //X有合成的移动操作
}

hasX hx,hx2 = std::move(hx); //使用合成的移动构造函数
```

-   移动操作永远不会隐式地定义为删除的函数
-   如果我们现实第要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数，例如：如果有类成员是const的或是引用，则类的移动赋值运算符将被定义为删除的
-    定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认被定义为删除的

#### 移动右值，拷贝左值……

-   如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数（穿左值用拷贝，传右值用移动）

#### ……但如果没有移动构造函数，右值也将被拷贝

-   如果一个类没有移动构造函数，函数匹配则确保该类的对象会被拷贝，即使我们使用move来移动，调用的也是拷贝构造函数
-   以上能成功的原因：可以将一个&&转换为const &（即右值引用转换为常量左值引用）
-   用拷贝构造函数代替移动构造函数几乎肯定是安全的（赋值运算的情况类似）

```c
Foo z(std::move(x)); //调用拷贝构造函数，因为未定义移动构造函数
```

#### 更新三/五法则

-   如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作

#### 移动迭代器

-   移动迭代器的解引用生成的是一个右值引用
-   通过标准库的`make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器，接受一个迭代器参数，返回一个移动迭代器
-   原迭代器的所有除解引用以外的操作都在移动迭代器中照常工作

```c
//construct将使用移动构造函数来创造元素（该类需要有移动构造函数）
uninitialized_copy(make_move_iterator(begin()),make_move_iterator(end()),first);
```

### 13.6.3 右值引用和成员函数

-   区分移动和拷贝的重载函数
    -   一个版本接受一个指向const的左值引用（拷贝）
    -   一个版本接受指向非const的右值引用（移动）

```c
void push_back(const X&); //拷贝：百度到任意类型的X，可以是std::move(x)
void push_back(X&&); //移动：只能帮到到类型X的可修改的右值，此版本对于非const的右值是精确匹配
```

#### 右值和左值引用成员函数

-   引用限定符可以是&或&&，分别指出**this可以指向一个左值或右值**
-   引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中
-   对于&限定的函数，调用该函数的对象只能是左值；对于&&限定的函数，调用该函数的对象只能是右值；对于没有限定的函数，调用该函数的对象可以是左值，也可以是右值  

```c
Foo &operator=(const Foo&) &;
```

```c
Foo &retFoo();  //返回一个引用，retFoo调用是一个左值
Foo retVal(); //返回一个值，retVal调用是一个右值
Foo i,j; //i和j是左值
i = j; //正确，i是左值
retFoo() = j; //正确，retFoo()是一个左值
retVal() = j; //错误，retVal()是一个右值
i = retVal(); //正确，可以将一个右值作为赋值操作的右侧运算对象
```

-   同时使用const和引用限定，引用限定符必须跟随在const限定符之后

```c
Foo anotherMem() const &;  //const表示this是一个指向常量的常指针，而&表示this指向的是一个左值，即调用对象为一个常量左值（其实一个右值也可以调用这个函数）

Foo Foo::sorted() const &
{
    Foo ret(*this); //拷贝一个副本  
    sort(ret.data.begin(),ret.data.end()); //排序副本
    return ret; //返回副本
}
```

#### 重载和引用函数

-   引用限定符可以用以区分重载版本
-   可以综合引用限定符和const来区分一个函数的重载版本

```c
class Foo {
public:
    Foo sorted() &&; //只能用于右值调用对象
    Foo sorted() const &; //可以用于任何类型的Foo（左值、右值），但如果是右值，又存在上一条函数，那么上一条函数为精确匹配

private:
    vector<int> data;
};
//本对象（*this）为右值，因此可以原地址排序
Foo Foo::sorted() &&
{
    sort(data.begin(),data.end());
    return *this;
}
//本对象（*this）是const的一个左值（这里原书有错），因为const所以不能原址排序，需要使用副本
Foo Foo::sorted() const &
{
    Foo ret(*this); //拷贝一个副本  
    sort(ret.data.begin(),ret.data.end()); //排序副本
    return ret; //返回副本
}

retVal().sorted(); //retVal()是一个右值，调用Foo sorted() &&
retFoo().sorted(); //retFoo()是一个左值，调用Foo sorted() const &
```

-   再举一例

```c
class Foo {
public:
    Foo sorted() &&; //只能用于右值调用对象
    Foo sorted() &; // 只能用于左值调用对象
}

Foo().sorted(); //调用的是Foo sorted() &&
Foo f;
f.sorted(); //调用的是Foo sorted() &
```

-   在const &函数中可以看到，当一个const右值或一个左值执行sorted时，我们不能改变对象，因此需要在排序前拷贝data

---

-   如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符

---

## 小结

-   拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符、析构函数
-   移动构造函数和移动赋值运算符接受一个（通常是非const的）右值引用
-   拷贝构造函数和拷贝赋值运算符接受一个（通常是const的）普通左值引用
-   如果一个类未声明以上五个操作，编译器会自动为其合成。如果这些操作未定义为删除的，它们会逐成员初始化、移动、赋值或销毁对象：合成的操作依次处理每个非static的数据成员，根据成员类型确定如何移动、拷贝、赋值或销毁它
-   一个类需要析构函数，则它肯定也需要定义移动和拷贝构造函数及移动和拷贝赋值运算符

---

# 第14章 重载运算与类型转换

14.1 基本概念

-   重载的运算符是具有特殊名字的函数
    -   它们的名字由operator加要定义的运算符组成
-   重载运算符的参数数量与该运算符作用的运算对象一样多，但就作为类成员的重载运算符函数，调用对象是隐式的第一个参数，所以参数列表会比运算符作用的运算对象少一个
-   除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认参数
-   运算符函数，参数至少有一个是类类型（不能全是内置类型），即
    -   或者是类的成员函数
    -   或者是至少含有一个类类型的参数的非成员函数

```c
int operator+(int,int); //非成员函数，错误，不能为int重定义内置的运算符
```

-   只能重载已有的运算符，不能发明新的运算符号
-   `+`、`-`、`*`、`&`既是一元运算符，也是二元运算符
    -   所有这些运算符都能被重载
    -   从参数的数量可以判断定义的是哪种运算符
-   重载运算符的优先级和结合律不会改变

---

-   运算符表如下：

![](https://raw.githubusercontent.com/guanjunjian/guanjunjian.github.io/master/img/study/study-20-cpp-primer-summary/tb_14_1.png)

#### 直接调用一个重载的运算符函数

-   可以像调用普通函数一样调用运算符函数

```c
//一个非成员函数的等价调用
data1+data2;
operator+(data1,data2);

//成员函数的等价调用
data1.operator+(data2);
```

#### 某些运算符不应该被重载

-   逻辑与、逻辑或、逗号运算符因重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它们
-   通常情况下也不重载取址符号

#### 使用与内置类型一致的含义

-   重载运算符的返回类型通常下应该与内置版本的返回类型兼容

#### 选择作为成员或非成员

-   有的运算符必须作为成员：赋值（`=`）、下标（`[]`）、调用（`()`）、成员访问箭头（`->`）
-   含有类对象的混合类型表达式，运算符必须定义成非成员函数，当我们把这样的运算符定义为成员函数时，它的左侧对象必须是运算符所属的类的一个对象，这样就不能交换运算符两侧的对象了

```c
string s = "word";
string t = s + "!"; //正确，string类重载了+
string u = "hi" + s; //如果+是string的成员，则错误
```

---

## 14.2 输入和输出运算符

### 14.2.1 重载输出运算符<<

-   第一个形参是一个非常量ostream对象的引用
-   第二个形参是一个常量的引用，该常量是我们要打印的类类型
-   返回第一个参数的引用
-   必须是非成员函数
-   且是第二个参数类类型的友元函数

```c
ostream &operator<<(ostream &os, const Sales_data &item);
```

## 14.2.2 重载输入运算符>>

-   第一个形参是运算符将要读取的流的引用
-   第二个参数是将要读入到的非常量对象的引用
-   返回某个给定流的引用
-   必须是非成员函数
-   且是第二个参数类类型的友元函数
-   输入运算符必须处理输入可能失败的情况，输出运算符不需要

```c
istream &operator>>(istream &is, Sales_data &item);
```

-   可能发生的错误：
    -   当流含有错误类型的数据读取操作可能失败
    -   当读取操作到达文件末尾或遇到输入流的其他错误时也会失败

---

## 14.3 算术和关系运算符

-   算术和关系运算符定义成非成员函数以允许左侧或右侧的运算对象进行转换
-   形参都是常量的引用

```c
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs);
```

### 14.3.1 相等运算符

-   通常情况下，相等运算符来检验两个对象是否相等，会比较对象的每一个数据成员
-   如果类定义了==，也应该定义!=，反之亦然

```c
bool operator==(const Sales_data &lhs, const Sales_data &rhs);

bool operator!=(const Sales_data &lhs, const Sales_data &rhs);
```

### 14.3.2 关系运算符

-   因为关联容器和一些算法要用到小于运算符，所以定义operator<比较有用

---

## 14.4 赋值运算符

-   运算符接受花括号内的元素列表作为参数

```c
strVec<string> v;
v = {"a","an","the"};

//这样定义赋值运算符就可以接受元素列表
strVec &operator=(std::initializer_list<std::string>);
```

-   无论形参的类型是什么，赋值运算符必须定义为成员函数

#### 复合赋值运算符

```c
//作为成员函数的二元运算符：左侧对象绑定到隐式的this指针
Sales_data &Sales_data::operator+=(const Sales_data &rhs);
```

---

## 14.5 下标运算符

-   必须是成员函数
-   返回值通常为所访问元素的引用，好处是下标运算符可以出现在赋值运算符的任意一端
-   如果一个类包含下标运算符，则它通常会定义两个版本：
    -   返回普通引用
    -   是类的常量成员并且返回常量引用，用于该类的常量对象的调用

```c
string& operator[](size_t n);
const string& operator[](size_t n) const;
```

---

## 14.6 递增和递减运算符

-   不要求，但建议将其设定为成员函数
-   应该同时定义前置和后置版本
-   前置运算符应该返回递增或递减后对象的引用，后置运算符应该返回对象递增或递减前的对象的值（非引用）
-   通过在后置版本参数中额外添加一个int来区分前置后置，这个形参的唯一作用就是区分前置版本和后置版本，不是真的要在实现后置版本时参与计算

```c
StrBlobPtr& operator++();  //前置++
StrBlobPtr operator++(int); //后置++
```

#### 显示地调用后置运算符

```c
p.operator++(0); //调用后置版本
p.operator++(); //调用前置版本
```

---

## 14.7 成员访问运算符

-   箭头运算符必须是类的成员
-   解引用运算符通常是类的成员

```c
class strBlobPtr {
public:
    string& operator*() const
    {
        auto p = check(curr,"dereference past end");
        return (*p)[curr];  //(*p)是对象所指的vector
    }
    
    string* operator->() const
    {
        //将实际工作委托给解引用运算符
        return & this->operator*();
    }
};

StrBlob a1 = {"hi","bye","now"};
strBlobPtr p(a1); //p指向a1的首元素赋值
/*
给a1的首元素赋值
相当于：
string &temp = (*p)[0]
temp = "okay"
*/
*p = "okay"; 
/*
打印4，即a1首元素的大小
相当于：
string *temp = &((*p)[0])
size_t c = temp.size();
cout << c << endl;
*/
cout << p->size() <<endl;
```

#### 对箭头运算符返回值的限定 

-   形如`point->mem`的表达式，point是：
    -   指向类对象的指针
    -   重载了operator->的类的对象
-   point->mem分别等价于

```c
(*point).mem; //point是一个内置的指针类型
point.operator->()mem; //point是类的一个对象
```

-   重载的箭头运算符必须返回：
    -   类的指针
    -   自定义了箭头运算符的某个类的对象

---

## 14.8 函数调用运算符

-   如果重载了函数调用运算符，则可以像使用函数一样使用该类的对象
-   函数调用运算符必须是成员函数
-   一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别
-   如果类定义了调用运算符，则该类的对象称作**函数对象**

```c
struct absInt {
    int operator()(int val) const {
        return val < 0 ? -val : val;
    }
};

    int i = -42;
    absInt absObj;             
    unsigned ui = absObj(i);  //将i传递给absObj.operator()(int)
```

### 14.8.1 lambda是函数对象

```c
stable_sort(words.begin(),word.end(),[](const string&a, const string&b)
                                            { return s1.size() < s2.size(); });
                                            
//其行为类似下面这个类的未命名对象
class shorterString
{
public:
    bool operator()(const string&a, const string&b) const
    { return s1.size() < s2.size(); }
}
```

-   在传入可调用对象的地方传入一个类对象，则会调用该对象的调用运算符

```c
stable_sort(words.begin(),word.end(),shorterString());
```

#### 表示lambda及相应捕获行为的类

```c
auto wc = find_if(words.begin(),word.end(),
                    [sz](const string &a)
                        { return a.size() >= sz; } );
                        


//该lambda表达式的类将形如：
class SizeComp{
    SizeComp(size_t n):sz(n){} //该形参对于捕获的变量
    bool operator()(const string &s) const
        { return s.size() >= sz; }
private:
    size_t sz; //该数据成员对应通过值捕获的变量
};

auto wc = find_if(words.begin(),word.end(),SizeComp(sz));
```

-   lambda表达式产生的类不含默认构造函数、赋值运算符、默认析构函数；是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员的类型而定

### 14.8.2 标准库定义的函数对象

-   标准库定义了一组表示算术运算符、关系运算符、逻辑运算符的类，每个类分别定义了一个指向命令操作的调用运算符
-   这些类都被定义成模板的形式
-   定义在functional头文件中

```c
plus<int> intAdd;  //可执行int加法的函数对
negate<int> intNegate; //可对int值取反的函数对象
//使用intAdd::operator(int,int)
int sum = intAdd(10,20); // sum = 30;
```

![](https://raw.githubusercontent.com/guanjunjian/guanjunjian.github.io/master/img/study/study-20-cpp-primer-summary/tb_14_2.png)

#### 在算法中使用标准库函数对象

```c
//传入临时的函数对象
//sort比较元素时，不再是使用默认的<运算符，而是调用给定的greater函数对象
sort(svec.begin(),svec.end(),greater<string>());
```

### 14.8.3 可调用对象与function

-   可调用对象：
    -   函数
    -   函数指针
    -   lamdba表达式
    -   bind创建的对象
    -   重载了函数调用运算符的类
-   可调用对象也有类型
-   两个不同类型的可调用对象却可能共享同一种调用形式
-   调用形式：指明了调用返回的类型以及传递给调用的实参类型
-   一种调用形式对应一个函数类型

```
//这是一个函数类型
int(int,int)
```

-   定义一个函数表有两个方法：
    -   使用函数指针
    -   使用标准库function类型

#### 函数指针实现函数表

```c
map<string,int(*)(int,int)> binops;
binops.insert("+",add); //add是一个函数名（也是函数的地址）
```

#### 标准库function类型实现函数表

-   定义在functional头文件
-   function是一个模板
-   function可以用可调用对象来初始化

![](https://raw.githubusercontent.com/guanjunjian/guanjunjian.github.io/master/img/study/study-20-cpp-primer-summary/tb_14_3.png)

```c
function<int(int,int)> f1 = add; //函数指针
function<int(int,int)> f2 = divide(); //函数对象类的对象
function<int(int,int)> f3 = [](int i,int j){ return i*j; }; //lambda

//调用function
f1(4,2);
```

-   使用function实现函数表

```c
map<string,function<int(int,int)>> binops;
binops.insert("+",add);
```

#### 重载的函数与function

-   不能（直接）将重载函数的名字存入function类型的对象中，会产生二义性，解决方法有：
    -   传入的是函数指针，而非函数的名字
    -   使用lambda表达式

```c
//函数指针的方式
int (*fp)(int,int) = add; //指针指向的add是接受两个int的版本
binops.insert({"+",fp}); //正确，fp指向一个正确的add版本

//lambda的方式
binops.insert({"+",[](int a,int b){return add(a,b);}});
```

---

## 14.9 重载、类型转换与运算符

-   **转换构造函数**和**类型转换运算符**共同定义了**类类型转换**，也称为**用户定义的类型转换**

### 14.9.1 类型转换运算符

-   类型转换函数的一般形式:

```c
operator type() const;
```

**以下均为类型转换运算符的描述：**

-   type表示某种类型
-   只要转换的目标类型可以作为返回类型，就允许定义这个类型的转换，因此：
    -   不允许转换成：数组、函数类型
    -   可以转换成：指针（包括数组指针、函数指针）、引用类型
-   必须是类的成员函数
-   不能声明返回类型，但实际上每个类型转换函数都会返回一个对应类型的值
-   形参列表必须为空，因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参
-   应该是const的

```c
class SmallInt{
public:
    //转换构造函数
    SmallInt(int i=0):val(i)
    {
        if(i<0 || i>255)
            throw std::out_of_range("Bad SmallInt value");
    }
    //类型转换运算符
    operator int() const { return val; }
}

SmallInt si;
si = 4; //首先将4隐式转换为SmallInt（调用转换构造函数），然后调用SmallInt::operator=
si + 3; //首先将si隐式转换成int（调用类型转换运算符），然后执行整数的加法
```

-   编译器一次只能执行一次用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用
    -   因此可以将任何算术类型（long int、double一类）传递给SmallInt的构造函数
    -   也可以用类型转换运算符将一个SmallInt对象转换成Int，再转换成任何其他算术类型

```c
//内置类型转换将double转为int，再调用SmallInt(int)构造函数
SmallInt si = 3.14; 
//SmallInt转为int（调用类型转换运算符），再内置类型转换将int转为double
si + 3.14
```

#### 显示的类型转换运算符

```c
class SmallInt{
public:
    //转换构造函数
    SmallInt(int i=0):val(i)
    {
        if(i<0 || i>255)
            throw std::out_of_range("Bad SmallInt value");
    }
    //类型转换运算符，阻止隐式转换
    explicit operator int() const { return val; }
}

SmallInt si = 3; //正确，构造函数可以不是显示的
si + 3; //错误，此处需要隐式类型转换，但类的运算符只能是显示转换
static_cast<int>(si) + 3; //正确，显示地请求类型转换
```

-   该规定存在一个例外，即如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它

### 14.9.2 避免有二义性的类型转换

-   产生多重路径有两种情况：
    -   第一种情况：两个类提供相同的类型转换：例如，当A定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符，同时存在两种由B获得A的方法，我们就说它们提供了相同的类型转换
    -   第二种情况：如果类定义了一组类型转换，它们的转换源（或者转换目标）类型本身可以通过其他类型转换联系在一起，则同样会产生二义性的问题。最典型的的例子是算术运算符，某个给定的类，最好只定义最多一个与算术类型有关的转换

#### 情况一：两个类提供相同的类型转换

```c
struct B;

struct A {
    A() = default;
    A(const B&); //把一个B转换成A
    ...
};

struct B {
    operator A() const; //也是一个B转换成A
    ...
};

A f(const A&); //一个函数
B b;
//二义性错误，同时存在两种由B获得A的方法
//含义是f(B::operator A())还是f(A::A(const B&))？
A a = f(b);

//如果显示调用则不会出错
A a1 = f(b.operator A());
A a2 = f(A(b));
```

#### 情况二：二义性与转换目标为内置类型的多重类型转换

```c
struct A {
    A(int = 0);  //最好不要创建两个转换源都是算术类型的类型转换
    A(double);
    operator int() const; //最好不要创建两个转换对象都是算术类型的转换
    operator double() const;
    ...
};

void f2(long double); //一个函数
A a;
//二义性错误
//含义是f(A::operator int())还是f(A::operator double())
f2(a);

long lg;
//二义性错误
//含义是A::A(int)还是A::A(double)
A a2(lg);
```

-   如果转换过程包含标准类型转换，则标准类型转换的级别将决定编译器选择最佳匹配的过程
-   注意“提升”和“转换”的区别

```c
short s = 42;
//把short提示成int优于short转换成double
//因此调用的是A::A(int)
A a3(s); 
```

#### 重载函数与转换构造函数

-   当几个重载函数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将进一步提升：

```c
struct C {
    C(int);
    ...
};

struct D {
    D(int);
    ...
};

void manip(const C&);
void manip(const D&);
//二义性错误
//含义是manip(C(10))还是manip(D(10))
manip(10);

//可以显示构造，这样可以消除二义性
manip(C(10));
```

#### 重载函数与用户定义的类型转换

```c
sturct E {
    E (double);
    ...
};

void manip2(const C&);
void manip2(const E&);

//二义性错误，两个不同的用户定义的类型转换都能用在此处
//含义是manip2(C(10))还是manip2(E(10))
//因为调用重载函数所请求的用户定义的类型转换不止一个且彼此不同，所以该调用具有二义性
manip2(10);
```

-   上例中，即使其中一个调用需要额外的类型标准转换而另一个调用能精确匹配，编译器也会将该调用标示为错误
-   在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性

### 14.9.3 函数匹配与重载运算符

-   如果a是一种类类型，则表达式a sym b可能是：

```c
a.operatorsym(b); //a是一个operator sym()成员函数
operatorsym(a,b); //operatorsym()是一个普通函数
```

-   不能通过调用的形式区分开当前调用的是成员函数还是非成员函数
-   使用运算符时有可能调用的是：
    -   内置版本
    -   非成员函数版本
    -   成员函数版本（如果左侧是类对象）
-   当我们调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载，因为使用的是调用命名函数的语法形式
-   而当我们在表达式中使用重载运算符时，无法判断正在使用的是成员函数还是非成员函数，因此二者都应该在考虑的范围内

```c
class SmallInt {
    friend SmallInt operator+(const SmallInt&, const SmallInt&);
public:
    SmallInt(int = 0);  //转换源为int的类型转换
    operator int() const{ return val; }; //转换目标为int的类型转换
private:
    std::size_t val;
};

SmallInt s1,s2;
SmallInt s3 = s1 + s2; //使用重载的operator+成员函数
//二义性错误
//含义是把0转换成SmallInt，然后使用重载的operator+成员函数
//还是把s3转换成int，使用执行int内置的加法运算
int i = s3 + 0; 
```

## 小结

-   赋值、下标、函数调用和箭头运算必须作为类的成员


