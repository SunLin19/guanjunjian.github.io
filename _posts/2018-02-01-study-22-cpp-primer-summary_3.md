---
layout:     post
title:      "「二十二」《C++Primber》笔记 第Ⅲ部分 "
date:       2018-02-02 20:00:00
author:     "guanjunjian"
categories: 阅读
tags:
    - study
    - summary
---

* content
{:toc}

>
> 《C++Primer》笔记 第Ⅲ部分 类设计者的工具
> 
> 包括第13至16章
> 
> [第13章 拷贝控制] [第14章 重载运算符与类型转换] [第15章 面向对象程序设计] [第16章 模板与泛型编程] 
> 
> 第五版 
>

# 第13章 拷贝控制

-   参考[《C++11学习笔记 (12)》](https://wenku.baidu.com/view/03218cd7960590c69ec37673.html)
-   当定义一个类时，我们显示地或隐式地指定在此类的对象拷贝、移动、赋值和销毁时做什么  
-   五种特殊的成员函数来控制这些操作，这些操作称为拷贝控制操作
    -   拷贝构造函数：定义了当用同类型的另一个对象初始化本对象时做什么
    -   拷贝赋值运算符：将一个对象赋予同类型的另一个对象时做什么
    -   移动构造函数：定义了当用同类型的另一个对象初始化本对象时做什么
    -   移动赋值运算符：将一个对象赋予同类型的另一个对象时做什么
    -   析构函数：定义了当此类型对象销毁时做什么
-   不显示定义这些操作，编译器也会为我们定义，但编译器定义的版本的行为可能并非我们所想

---




## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

-   如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值（即调用时最少只需要传入一个参数），则此构造函数为拷贝构造函数
-   第一个参数必须是一个引用类型，虽然可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用
-   拷贝构造函数在很多情况下都会被隐式使用，因此，拷贝构造函数通常不应该是explicit的

```c
class Foo{
public:
    Foo(); //默认构造函数
    Foo(const Foo&); //拷贝构造函数
}
```

#### 合成拷贝构造函数

-   即使我们定义了其他构造函数，但是没有定义拷贝构造函数，那么编译器也会为我们合成一个默认拷贝构造函数
-   合成拷贝构造函数的作用有两种（它们是或关系）：
    -   用来组织我们拷贝该类的对象
    -   将其参数的成员逐个拷贝到正在创建的对象中，依次将每个非static成员拷贝到正在创建的对象中
-   合成拷贝构造函数如何拷贝成员，由成员的类型决定：
    -   类类型：使用其拷贝构造函数拷贝
    -   内置类型（除了数组）：直接拷贝
    -   内置数组：逐元素地拷贝

#### 拷贝初始化

-   区分直接初始化与拷贝初始化：
    -   直接初始化实际上是要求编译器使用普通的函数匹配来选择最匹配的构造函数创建一个对
    -   拷贝初始化则是要求编译器将右侧运算对象拷贝到正在创建的对象中（调用拷贝构造函数？？不应该是调用拷贝赋值运算符吗？），如果需要的化还要进行类型转换

```c
string dots(10,'.');     //直接初始化
string s(dots);           //直接初始化
string s2=dots;        //拷贝初始化
string null_book="9-999-99999-9";    //拷贝初始化
string nines=string(100,'9');        //拷贝初始化
```

-   拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生
    -   将一个对象作为实参传递给一个非引用类型的形参时  
    -   从一个函数返回一个非引用类型的对象时
    -   用花括号初始化一个数组中的元素或一个聚合类中的成员时
    -   某些类类型还会对它所分配的对象使用拷贝初始化，如初始化标准库容器或是调用其insert或push成员，进行的是拷贝初始化；调用emplace进行的直接初始化

#### 参数和返回值

-   为什么拷贝构造函数自己的参数必须是引用类型：
    -   因为拷贝构造函数被用来初始化非引用类类型参数，如果其参数不是引用类型，则调用永远不会成功

### 13.1.2 拷贝赋值运算符

-   类可以控制其对象如何赋值
-   如果类未定义自己的拷贝赋值运算符，那么编译器也会合成一个默认的拷贝赋值运算符

#### 重载赋值运算

-   重载运算符将在14章详细介绍，这里先是简单的说一下
-   重载运算符本质上是函数，其函数名由operator关键字后接表示要定义的运算符的符号组成，对于赋值运算符来说就是名为`operator=`的函数
-   重载运算符的参数表示运算符的运算对象，某些运算符，包括赋值运算符，必须定义为成员函数
-   如果一个运算符时一个成员函数
    -   其左侧运算对象就绑定到隐式的this参数
    -   对于一个二元运算符，例如赋值运算，其右侧运算对象作为显示参数传递

```c
class Foo{
public:
Foo& operator=(const Foo&);    //赋值运算符
}
```

-   赋值运算符通常返回一个指向其左侧运算对象的引用，标准库通常要求保存在容器中的类型要具有赋值运算符，且返回值是其左侧对象的引用

#### 合成拷贝赋值运算符

-   合成拷贝赋值运算符的作用有两种（它们是或关系）：
    -   用来禁止该类对象的赋值
    -   将右侧运算对象的每个非static成员赋予运算符左侧运算对象的对应成员
-   合成拷贝赋值运算符如何赋值成员，由成员的类型决定：
    -   类类型：使用其拷贝赋值运算符
    -   内置类型（除了数组）：直接赋值
    -   内置数组：逐元素地赋值    

```c
//等价于合成拷贝运算符
Sales_data& Sales_data::operator=(const Sales_data &rhs)
{
	bookNo = rhs.bookNo;          // calls the string::operator=
	units_sold = rhs.units_sold;  // uses the built-in int assignment
	revenue = rhs.revenue;        // uses the built-in double assignment
	return *this;                 // return a reference to this object
}
```

### 13.1.3 析构函数

-   析构函数释放函数对象使用的资源，并且销毁对象的非static数据成员
-   析构函数是类的成员函数，其没有返回值，也不接受任何参数，所以其不可以被重载，对一个给定类，只会有一个唯一的析构函数
-   函数名由波浪号接类名构成

```c
class Foo{
public:
    ~Foo(); //析构函数
}
```

#### 析构函数完成什么工作

-   析构函数由一个函数体和析构部分组成
    -   首先执行函数体
    -   然后执行析构部分（析构部分是隐式的），销毁成员，成员销毁按初始化顺序的逆序销毁
-   成员销毁时发生什么完全依赖于成员的类型
    -   类类型：执行自己的析构函数（智能指针是类类型，具有析构函数，在析构阶段会被自动销毁）
    -   内置类型：什么也不做（注意：隐式销毁内置指针类型的成员不会delete它所指向的对象）

#### 什么时候调用析构函数

-   无论何时一个对象被销毁，就会自动调用其析构函数：
    -   变量在离开其作用域时被销毁  
    -   当一个对象呗销毁，其成员被销毁
    -   容器（标准容器或数组）被销毁时，其元素被销毁
    -   动态分配的对象，当对指向它的指针应用delete时被销毁
    -   对于临时对象，创建它的完整表达式结束时被销毁
-   析构函数是自动运行的
-   当指向一个对象的引用或指针离开作用域时，被指向的对象的析构函数不会执行

#### 合成析构函数

-   当类未定义自己的析构函数时，编辑器会自己定义一个合成析构函数
    -   对于某些类，合成析构函数被用来阻止该类型的对象被销毁
    -   如果不是以上情况，合成析构函数的函数体就为空。在（空）析构函数执行完毕后，成员会被自动销毁（标准库的类会自动释放，内置类型变量什么也不做，指针指向的对象不会被销毁）
-   析构函数自身并不直接销毁成员。成员实在析构函数体之后隐含的析构阶段中被销毁的
-   析构函数体是作为成语销毁之外的另一部分而进行的

### 13.1.4 三/五法则

-   如果一个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
-   如果一个雷需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符，反之亦然
-   无论是需要拷贝构造函数还是拷贝赋值运算符都不必然意味着也需要析构函数

### 13.1.5 使用=default

-   将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本
-   当我们在类内使用=default时，合成的函数将隐式的声明为内联函数，如果我们不需要内联应该只在类外定义时使用=default
-   只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）

```c
~Sales_data() =default; //显示的要求编译器生成合成的析构函数
```

### 13.1.6 阻止拷贝

-   有时候类必须采取某种机制阻止拷贝和赋值
    -   iostream类就阻止了拷贝，以避免多个对象写入或读取相同IO缓冲

#### 定义删除的函数

-   通过将拷贝构造函数和拷贝运算符定义成删除的函数来阻止拷贝
-   虽然声明了它们，但不能以任何方式使用它们
-   方式是在参数列表后加上=default来指出我们希望将它定义为删除的
-   =delete通知编译器（以及代码的读者），我们不希望定义这些成员
-   与=default不同之处
    -   =delete必须是在函数第一次声明出现的时候
    -   可以对任何函数指定delete（除了析构函数）
-   当我们希望引导函数匹配过程时，删除函数有时也是很有用的

```c
struct NoCopy{
    ...
    NoCopy(const NoCapy& ) = delete; //阻止拷贝构造函数
    ...
}
```

#### 析构函数不能是删除的成员

-   我们不能定义析构函数时删除函数
-   如果将析构函数定义成删除函数（或是类的某个成员的类型是删除析构函数），我们不能定义该类的变量或临时对象
-   可以定义动态分配这种类型的对象。但是，不能释放这些对象

```c
struct NoDtor{
    NoDtor() = default;
    ~NoDtor() = delete;
}

NoDtor nd; //错误，NoDtor的析构函数是删除的 
NoDtor *p = new NoDtor(); //正确
delete p; //错误，NoDtor的析构函数是删除的
```

#### 合成的拷贝控制成员可能是删除的

-   如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
-   一个成员由删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的
-   对于具有引用成员或const成员的类，编译器不会为其合成默认构造函数，也不能使用合成的拷贝赋值运算符
    -   原因：试图赋值所有成员，而将一个新值赋予一个const对象是不可能的

#### private拷贝控制

-   在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝的
-   为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但并不定义它们
-   声明但不定义一个成员函数是合法的，对此只有一个例外（将在15.2.1介绍）
    -   试图访问一个未定义的成员将导致一个链接时错误
-   通过声明（但不定义）private的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图
    -   试图拷贝对象的用户代码将在编译阶段被标记为错误
    -   成员函数或友元函数中的拷贝操作将导致链接时错误

---

## 13.2 拷贝控制和资源管理

-   拷贝控制和资源管理有两种方式
    -   令类的行为像一个值
    -   令类的行为像一个指针
-   但也有既不像值也不像指针，例如IO类和unique_ptr不允许拷贝和赋值
-   如何拷贝指针成员决定了类是具有类值行为还是类指针行为

### 13.2.1 行为像值的类

-   类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝
-   当你编写赋值运算符时，需要记住：如果将一个对象赋予它自身，赋值运算必须能正确工作（最主要的是赋值和销毁的顺序）。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象

### 13.2.2 定义行为像指针的类

-   类似指针的类，拷贝指针成员本身而不是它指向的内容
-   仍然需要自己的析构函数来释放指针成员指向的内存，但不能单方面地释放，只有当最后一个指向该内存的类的成员销毁时，才可以释放。最好的方法是使用shared_ptr

---

## 13.3 交换操作

-   管理资源的类通常还定义一个名为swap的函数
-   如果一个类定义了自己的swap，那么算法将使用类自定义版本；否则算法会使用标准库中的swap
-   内置类型是没有特定版本的swap的，所以会调用标准库的std::swap；如果一个类的成员有自己类型特定的swap函数，调用std::swap就是错误的了
-   如果存在类型特定的swap版本，其匹配程序优于std中定义的版本，不存在时才会调用std::swap

#### 在赋值运算符中使用swap

-   定义swap的类通常用swap来定义它们的赋值运算符，这些运算符使用了一种名为拷贝并交换的技术

```c
//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数将右侧运算对象拷贝的rhs
HasPtr& HasPtr::operator = (HasPtr rhs) {
    //交换左侧运算对象和局部变量rhs的内容
    swap(*this, rhs); //rhs现在只想本对象曾经使用的内存
    return  *this;  //局部变量rhs离开函数体，它被销毁，从而delete了rhs中的指针
} 
```

---

## 13.6 对象移动

-   存在对象移动的原因：
    -   在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素
    -   IO类或unique_ptr这样的类，都包含了不能被共享的资源（如指针或IO缓冲），因此这些类的对象不能拷贝只能移动

### 13.6.1 右值引用

-   右值引用：必须绑定到右值的引用，但只能绑定到一个将要销毁的对象，通过&&来获得右值的引用
-   我们可以自由地将一个右值引用的资源“移动”到另一个对象中
-   一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值
-   右值表达式可以绑定到：
    -   要求转换的表达式
    -   字面常量
    -   返回右值的表达式

```c
int i = 42;
int &r = i; // 正确
int &&rr = i ; // 错误，不能将一个右值引用绑定到一个左值上
int &r2 = i * 42 ; // 错误，i*42是右值
const int &r3 = i*42; // 正确，我们可以将一个 const 的引用绑定到一个右值上
int &&rr2 = i * 42 // 正确
```

-   右值引用或const的左值引用都可以绑定到右值上

-   返回左值的例子：
    -   返回左值引用的函数   
    -   赋值运算符
    -   下标运算符
    -   解引用运算符
    -   前置递增/递减运算符
-   返回右值的例子
    -   返回非引用类型的函数
    -   算术运算符
    -   关系运算符
    -   位运算符
    -   后置递增/递减运算符   

#### 左值持久，右值短暂

-   左值有持久的状态
-   右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，都具有短暂性
-   由于右值引用只能绑定到临时对象，我们知道
    -   所引用的对象将要被销毁
    -   该对象没有其他用户
-   使用右值引用的代码可以自由地接管所引用的对象的资源

-   变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变是右值引用类型也不行

```c
int &&rr1 = 42; //正确，字面值常量是右值
int &&rr2 = rr1; //错误，表达式rr1是左值
```

#### 标准库move函数

-   可以显式的将一个左值转换为对应的右值引用类型
-   调用move，在头文件utility中
-   move告诉编译器，我们有一个左值，但我们希望像右值一样处理它
-   调用move就意味着承诺：除了对rr1赋值或销毁它外，将不再使用它，即对于移后源对象，可以销毁，可以赋值，但不能再使用它的值

```c
int &&rr3 = std::move(rr1); //正确
```

### 13.6.2 移动构造函数和移动赋值运算符

-   移动构造函数和移动赋值运算符从给定的对象“窃取”资源而不是拷贝资源
-   移动构造函数的第一个参数是该类类型的以个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参
-   一旦资源完成移动，源对象必须不再指向被移动的资源，这些资源的所有权已经归属新创建的对象

```c
//noexcept表示：移动操作不抛出任何异常
//成员初始化其接管s中的资源
StrVec:StrVec(StrVec &&s) noexcept :: elements(s.elements) ,first_free(s.first_free) , cap(s.cap)
{
    //令s中的指针成员为空，对其运行析构函数后，就不会释放之前它指向的资源
    s.elements = s.first_free = s.cap =nullptr;
}
```

#### 移动操作、标准库容器和异常

-   由于移动资源，通常是不分配任何资源的，因此通常不会抛出任何异常
-   当编写一个不抛出异常的移动操作时，我们应该告诉标准库，来阻止标准库为了处理抛出异常的可能性而做的一些额外的工作
-   一种通知方法就是使用noexcept，必须在声明和定义（如果定义在类外）都指定noexcept
-   不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
-   如果希望在vector重新分配内存这类情况下对自己定义类型的对象进行移动而不是拷贝，那么就显示的告诉标准库我们的移动构造函数可以安全的使用。通过标记为noexcept来做到

#### 移动赋值运算符

-   移动赋值运算符执行与析构函数和移动构造函数相同的工作（析构函数+移动构造函数）

#### 移后源对象必须可解析

-   编写一个移动操作时，必须确保移后源对象进入一个可解析的状态（如将指针成员设为nullptr）
-   在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其值进行任何假设

#### 合成的移动操作

-   编译器会合成移动构造函数和移动赋值运算符
-   如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符
-   如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来替代
-   只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编辑器才会为他们合成移动构造函数或移动赋值运算符
-   编译器可以移动内置类型成员，还能移动定义了对应移动操作的类

```c
struct X hasX{
    X mem; //X有合成的移动操作
}

hasX hx,hx2 = std::move(hx); //使用合成的移动构造函数
```

-   移动操作永远不会隐式地定义为删除的函数
-   如果我们现实第要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数，例如：如果有类成员是const的或是引用，则类的移动赋值运算符将被定义为删除的
-    定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认被定义为删除的

#### 移动右值，拷贝左值……

-   如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数（穿左值用拷贝，传右值用移动）

#### ……但如果没有移动构造函数，右值也将被拷贝

-   如果一个类没有移动构造函数，函数匹配则确保该类的对象会被拷贝，即使我们使用move来移动，调用的也是拷贝构造函数
-   以上能成功的原因：可以将一个&&转换为const &（即右值引用转换为常量左值引用）
-   用拷贝构造函数代替移动构造函数几乎肯定是安全的（赋值运算的情况类似）

```c
Foo z(std::move(x)); //调用拷贝构造函数，因为未定义移动构造函数
```

#### 更新三/五法则

-   如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作

#### 移动迭代器

-   移动迭代器的解引用生成的是一个右值引用
-   通过标准库的`make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器，接受一个迭代器参数，返回一个移动迭代器
-   原迭代器的所有除解引用以外的操作都在移动迭代器中照常工作

```c
//construct将使用移动构造函数来创造元素（该类需要有移动构造函数）
uninitialized_copy(make_move_iterator(begin()),make_move_iterator(end()),first);
```

### 13.6.3 右值引用和成员函数

-   区分移动和拷贝的重载函数
    -   一个版本接受一个指向const的左值引用（拷贝）
    -   一个版本接受指向非const的右值引用（移动）

```c
void push_back(const X&); //拷贝：百度到任意类型的X，可以是std::move(x)
void push_back(X&&); //移动：只能帮到到类型X的可修改的右值，此版本对于非const的右值是精确匹配
```

#### 右值和左值引用成员函数

-   引用限定符可以是&或&&，分别指出**this可以指向一个左值或右值**
-   引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中
-   对于&限定的函数，调用该函数的对象只能是左值；对于&&限定的函数，调用该函数的对象只能是右值；对于没有限定的函数，调用该函数的对象可以是左值，也可以是右值  

```c
Foo &operator=(const Foo&) &;
```

```c
Foo &retFoo();  //返回一个引用，retFoo调用是一个左值
Foo retVal(); //返回一个值，retVal调用是一个右值
Foo i,j; //i和j是左值
i = j; //正确，i是左值
retFoo() = j; //正确，retFoo()是一个左值
retVal() = j; //错误，retVal()是一个右值
i = retVal(); //正确，可以将一个右值作为赋值操作的右侧运算对象
```

-   同时使用const和引用限定，引用限定符必须跟随在const限定符之后

```c
Foo anotherMem() const &;  //const表示this是一个指向常量的常指针，而&表示this指向的是一个左值，即调用对象为一个常量左值（其实一个右值也可以调用这个函数）

Foo Foo::sorted() const &
{
    Foo ret(*this); //拷贝一个副本  
    sort(ret.data.begin(),ret.data.end()); //排序副本
    return ret; //返回副本
}
```

#### 重载和引用函数

-   引用限定符可以用以区分重载版本
-   可以综合引用限定符和const来区分一个函数的重载版本

```c
class Foo {
public:
    Foo sorted() &&; //只能用于右值调用对象
    Foo sorted() const &; //可以用于任何类型的Foo（左值、右值），但如果是右值，又存在上一条函数，那么上一条函数为精确匹配

private:
    vector<int> data;
};
//本对象（*this）为右值，因此可以原地址排序
Foo Foo::sorted() &&
{
    sort(data.begin(),data.end());
    return *this;
}
//本对象（*this）是const的一个左值（这里原书有错），因为const所以不能原址排序，需要使用副本
Foo Foo::sorted() const &
{
    Foo ret(*this); //拷贝一个副本  
    sort(ret.data.begin(),ret.data.end()); //排序副本
    return ret; //返回副本
}

retVal().sorted(); //retVal()是一个右值，调用Foo sorted() &&
retFoo().sorted(); //retFoo()是一个左值，调用Foo sorted() const &
```

-   再举一例

```c
class Foo {
public:
    Foo sorted() &&; //只能用于右值调用对象
    Foo sorted() &; // 只能用于左值调用对象
}

Foo().sorted(); //调用的是Foo sorted() &&
Foo f;
f.sorted(); //调用的是Foo sorted() &
```

-   在const &函数中可以看到，当一个const右值或一个左值执行sorted时，我们不能改变对象，因此需要在排序前拷贝data

---

-   如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符

---

## 小结

-   拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符、析构函数
-   移动构造函数和移动赋值运算符接受一个（通常是非const的）右值引用
-   拷贝构造函数和拷贝赋值运算符接受一个（通常是const的）普通左值引用
-   如果一个类未声明以上五个操作，编译器会自动为其合成。如果这些操作未定义为删除的，它们会逐成员初始化、移动、赋值或销毁对象：合成的操作依次处理每个非static的数据成员，根据成员类型确定如何移动、拷贝、赋值或销毁它
-   一个类需要析构函数，则它肯定也需要定义移动和拷贝构造函数及移动和拷贝赋值运算符



