---
layout:     post
title:      "study17.《C和指针》知识点"
date:       2018-01-09 10:00:00
author:     "guanjunjian"
categories: 读书
tags:
    - study
---

* content
{:toc}

>
> 《C和指针》 知识要点
>




# 第7章 函数

## 7.1 函数定义

-   函数的定义就是函数体的实现
-   函数声明出现在函数被调用的地方，函数声明向编译器提供函数的相关信息，用于确保函数被正确地调用
-   存根(stub)：应该就是一个空函数。编写这类存根，或者说为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性，以便于你编译和测试程序的其他部分
    ```
    function_name()
    {
        
    }
    ```
-   过程类型的函数：没有返回值
-   真函数：从表达式内部调用的，必须返回一个值，用于表达式的求值

---

## 7.2 函数声明

### 7.2.1 原型

-   第2种向编译器提供函数信息的方法是使用函数原型（第1种应该是函数定义）
-   使用原型最方便的方法是把原型置于一个单独的文件，使用`#include`指令包含该文件
-   `int func( int i );`中`;`区分了函数原型和函数定义的起始部分
-   原型中的参数名字并不是必需的
-   函数原型具有文件作用域，所以原型的一份拷贝可以作用于整个源文件
-   函数原型必须与函数定义匹配
-   `int *func()`不能表示一个没有参数的函数的原型，因为旧式风格的有参函数是可以这样声明的，一个没有参数的函数原型应该写成`int *func(void)`

### 7.2.2 函数的缺省认定

-   当程序调用一个无法见到原型的函数时，编译器认为该函数返回一个整型值
-   所有的函数都应该具有原型，尤其是那些返回值不是整型的函数
-   如果编译器认定函数返回一个整型值，它将产生整型数指令操作这个值（如果返回的不是整型值，那将会出错，例子参考P121）

---

## 7.3 函数的参数

-   1. 所有参数均以“传值调用”方式进行传递，这意味着函数将获得参数值的一份拷贝
-   2. 数组并不会得到一份拷贝，而是得到数组首地址的一份拷贝，这个行为被称为“传值调用”，因为数组名的值实际上是一个指针，传递给函数的就是这个指针的一份拷贝
-   3. 记住两个规则：
        -   1. 传递给函数的标量参数是传值调用的
        -   2. 传递给函数的数组参数在行为上就像它们是通过传址调用的那样
-   4. 在函数参数声明中，声明数组参数时不指定它的长度是合法的，因为函数并不为数组元素分配内存

---

## 7.4 ADT和黑盒

-   C可以用于设计和实现抽象数据类型（ADT，abstract data type），也被称为黑盒设计
-   抽象数据类型的基本想法：模块具有功能说明和接口说明
-   限制对模块的访问是通过`static`关键字的合理使用实现的，它可以限制那些并非接口的函数和数据的访问

---

## 7.5 递归

-   C通过运行时堆栈支持递归函数的实现，递归函数就是直接或间接调用自身的函数。

### 7.5.1 追踪递归函数

-   追踪一个递归函数执行过程的关键是理解函数中所声明的变量是如何存储的，因此可以通过画堆栈图来理解（参考P128的例子）

### 7.5.2 递归与迭代

-   1. 递归函数调用将涉及一些运行时开销
        -   参数必须压到堆栈中
        -   为局部变量分配内存空间
        -   寄存器的值必须保存
-   2. 因此递归函数的开销是十分大的
-   3. 尾部递归：当一个函数在递归调用返回之后不再执行任何任务，这样的递归函数叫尾部递归
-   4. 尾部递归可以很方便地转换成一个简单循环，完成相同任务，但开销更小
-   5. 迭代实现往往比递归实现效率更高，但代码可读性稍差
-   6. 如果一个问题相当复杂，难以用迭代形式实现时，此时递归实现的简便性可以补偿它所带来的运行时开销

---

## 7.6 可变参数列表

-   1. 宏是由预处理器实现的
-   2. 可变参数列表是通过宏来实现的，这些宏定义于stdarg.h头文件，它是标准库的一部分
-   3. 分别有一个类型`va_list`和三个宏`va_start`、`va_arg`和`va_end`
-   4. 参数列表中的省略号提示此处可能传递数量和类型未确定的参数，编写函数原型时，也要使用同样的记法
-   5. 可变参数必须从头到尾按顺序逐个访问，半途终止是可以的，但不能一开始就访问参数列表中的中间的参数
-   6. 由于可变参数部分没有原型，可变参数传递给函数的值都将执行缺省参数类型的提升（//TODO 不明白什么意思）
-   7. 这些宏存在两个基本限制，是由“一个值的类型无法简单地通过检查它的位模式来判断”导致的
        *   这些宏无法判断实际存在的参数的数量
        *   这些宏无法判断每个参数的类型
-   8. 要回答`7.`中的两个问题，就必须使用命名参数
        

```c
#include <stdarg.h>

float
average ( int n_values, ...)
{
    //用于访问参数列表的未确定部分
    va_list var_agr;
    int count;
    float sum = 0;
    
    //使用va_start来初始化，第1个参数是va_list变量的名字，第2个参数是省略号前最后一个有名字的参数，初始化过程把var_arg变量指向可变参数部分的第1个参数
    va_start( var_agr, n_values );
    
    for( count =0; count < n_values; count +=1 ){
        //访问参数，第1个变量va_list变量，第2个变量，参数列表中下一个参数的类型。va_arg返回这个参数的值，并使var_arg指向下一个可变参数
        sum += va_arg( var_arg, int );
    }
    //访问完毕最后一个可变参数之后，需要调用va_end
    va_end( var_arg );
    
    return sum / n_values;
}
```
---

## 7.7 总结

-   1. 参数列表有两种可以接受的形式：K&R C风格和新风格
-   2. 函数声明也有两种可以接受的形式：
        *   K&C C每个没有参数列表，只声明了返回值的类型
        *   新风格又称为函数原型，包含了参数列表的声明
-   3. 对于那些没有原型的函数，传递给函数的实参将进行缺省参数提升
        *   char和short转换为int
        *   float转换为double

